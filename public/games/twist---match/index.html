<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Twist & Match - Sensor Puzzle Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            touch-action: none;
        }

        #gameCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* ì„¸ì…˜ íŒ¨ë„ - ì¢Œì¸¡ ìƒë‹¨ (ê²Œì„ í™”ë©´ ì•ˆ ê°€ë¦¼) */
        .session-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            max-width: 220px;
            backdrop-filter: blur(10px);
        }

        .session-panel h3 {
            font-size: 14px;
            color: #667eea;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .session-code-display {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 3px;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        #qr-code {
            text-align: center;
            margin-top: 10px;
            background: white;
            padding: 10px;
            border-radius: 10px;
        }

        #qr-code img {
            max-width: 150px;
            max-height: 150px;
            border-radius: 8px;
        }

        /* ê²Œì„ ì •ë³´ - ìš°ì¸¡ ìƒë‹¨ */
        .game-info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 20px;
            border-radius: 15px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            min-width: 180px;
            backdrop-filter: blur(10px);
        }

        .game-info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .game-info-item:last-child {
            margin-bottom: 0;
        }

        .game-info-label {
            color: #667eea;
            font-weight: 600;
            margin-right: 10px;
        }

        .game-info-value {
            color: #333;
            font-weight: bold;
            font-size: 18px;
        }

        /* ì„¼ì„œ ìƒíƒœ - ì¢Œì¸¡ í•˜ë‹¨ */
        #sensor-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            color: #666;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        #sensor-status.connected {
            background: linear-gradient(135deg, #11998e, #38ef7d);
            color: white;
        }

        #sensor-status.disconnected {
            background: rgba(255, 255, 255, 0.95);
            color: #999;
        }

        /* í† ìŠ¤íŠ¸ ë©”ì‹œì§€ */
        #toast-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            z-index: 999;
            pointer-events: none;
            transition: opacity 0.3s ease;
            display: none;
            opacity: 0;
            text-align: center;
            max-width: 80%;
        }

        /* ì˜¤ë²„ë ˆì´ */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }

        .overlay.hidden {
            display: none;
        }

        .overlay-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .overlay-title {
            font-size: 32px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 20px;
        }

        .overlay-message {
            font-size: 18px;
            color: #666;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .overlay-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .overlay-button:hover {
            transform: translateY(-2px);
        }

        .overlay-button:active {
            transform: translateY(0);
        }

        /* íŒíŠ¸ ë²„íŠ¼ - ìš°ì¸¡ í•˜ë‹¨ */
        #hint-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #f093fb, #f5576c);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(245, 87, 108, 0.4);
            transition: transform 0.2s ease;
        }

        #hint-button:hover {
            transform: translateY(-2px);
        }

        #hint-button:active {
            transform: translateY(0);
        }

        #hint-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 768px) {
            .session-panel {
                max-width: 180px;
                padding: 12px;
            }

            .session-code-display {
                font-size: 20px;
                padding: 10px;
            }

            #qr-code img {
                max-width: 120px;
                max-height: 120px;
            }

            .game-info {
                min-width: 150px;
                padding: 12px 15px;
            }

            .game-info-item {
                font-size: 14px;
            }

            .game-info-value {
                font-size: 16px;
            }

            .overlay-title {
                font-size: 24px;
            }

            .overlay-message {
                font-size: 16px;
            }

            #hint-button {
                padding: 12px 20px;
                font-size: 14px;
            }
        }

        /* ë¡œë”© ì• ë‹ˆë©”ì´ì…˜ */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜ */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <!-- ê²Œì„ ìº”ë²„ìŠ¤ -->
    <canvas id="gameCanvas"></canvas>

    <!-- ì„¸ì…˜ íŒ¨ë„ -->
    <div class="session-panel">
        <h3>ğŸ“± ì„¸ì…˜ ì½”ë“œ</h3>
        <div class="session-code-display">
            <span id="session-code">----</span>
        </div>
        <div id="qr-code"></div>
    </div>

    <!-- ê²Œì„ ì •ë³´ íŒ¨ë„ -->
    <div class="game-info">
        <div class="game-info-item">
            <span class="game-info-label">ë ˆë²¨:</span>
            <span class="game-info-value" id="level-display">1</span>
        </div>
        <div class="game-info-item">
            <span class="game-info-label">ì ìˆ˜:</span>
            <span class="game-info-value" id="score-display">0</span>
        </div>
        <div class="game-info-item">
            <span class="game-info-label">ì‹œê°„:</span>
            <span class="game-info-value" id="timer-display">60</span>
        </div>
        <div class="game-info-item">
            <span class="game-info-label">íŒíŠ¸:</span>
            <span class="game-info-value" id="hints-display">3</span>
        </div>
    </div>

    <!-- ì„¼ì„œ ìƒíƒœ -->
    <div id="sensor-status" class="disconnected">
        ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...
    </div>

    <!-- íŒíŠ¸ ë²„íŠ¼ -->
    <button id="hint-button">ğŸ’¡ íŒíŠ¸ ì‚¬ìš©</button>

    <!-- í† ìŠ¤íŠ¸ ë©”ì‹œì§€ -->
    <div id="toast-message"></div>

    <!-- ì˜¤ë²„ë ˆì´ -->
    <div id="overlay" class="overlay hidden">
        <div class="overlay-content">
            <div class="overlay-title">Twist & Match</div>
            <div class="overlay-message">
                ê¸°ê¸°ë¥¼ íšŒì „ì‹œì¼œ í¼ì¦ ì¡°ê°ì„ ë§ì¶”ì„¸ìš”!<br>
                <br>
                <strong>ì¡°ì‘ ë°©ë²•:</strong><br>
                ğŸ“± ê¸°ê¸°ë¥¼ ì¢Œìš°ë¡œ ê¸°ìš¸ì´ë©´ í¼ì¦ì´ íšŒì „í•©ë‹ˆë‹¤<br>
                ğŸ¯ ëª¨ë“  ì¡°ê°ì„ ì˜¬ë°”ë¥¸ ë°©í–¥ìœ¼ë¡œ ë§ì¶”ì„¸ìš”<br>
                â±ï¸ ì œí•œ ì‹œê°„ ë‚´ì— í¼ì¦ì„ ì™„ì„±í•˜ì„¸ìš”
            </div>
            <button class="overlay-button" onclick="hideOverlay()">ì‹œì‘í•˜ê¸°</button>
        </div>
    </div>

    <!-- í•„ìˆ˜ ìŠ¤í¬ë¦½íŠ¸ -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/SessionSDK.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <script>
        // ==================== ê²Œì„ ìƒìˆ˜ ì •ì˜ ====================
        const CANVAS_WIDTH = window.innerWidth;
        const CANVAS_HEIGHT = window.innerHeight;
        
        const PUZZLE_TYPES = {
            SQUARE: 'square',
            TRIANGLE: 'triangle',
            CIRCLE: 'circle',
            DIAMOND: 'diamond',
            HEXAGON: 'hexagon'
        };

        const COLORS = {
            PRIMARY: '#667eea',
            SECONDARY: '#764ba2',
            SUCCESS: '#38ef7d',
            WARNING: '#f5576c',
            CORRECT: '#4CAF50',
            INCORRECT: '#FF5252',
            NEUTRAL: '#FFF',
            SHADOW: 'rgba(0, 0, 0, 0.2)'
        };

        const DIFFICULTY_SETTINGS = {
            easy: { gridSize: 2, timeLimit: 90, rotationSpeed: 3 },
            medium: { gridSize: 3, timeLimit: 60, rotationSpeed: 4 },
            hard: { gridSize: 4, timeLimit: 45, rotationSpeed: 5 }
        };

        const ROTATION_ANGLES = [0, 90, 180, 270];
        const SENSOR_THRESHOLD = 8; // ì„¼ì„œ ê°ì§€ ì„ê³„ê°’ (15 â†’ 8ë¡œ ë¯¼ê°ë„ í–¥ìƒ)
        const ROTATION_COOLDOWN = 150; // íšŒì „ ì¿¨ë‹¤ìš´ (ms) (300 â†’ 150ìœ¼ë¡œ ë°˜ì‘ì†ë„ í–¥ìƒ)
        const HINT_DURATION = 3000; // íŒíŠ¸ í‘œì‹œ ì‹œê°„ (ms)

        // ==================== ê²Œì„ ë³€ìˆ˜ ====================
        let canvas, ctx;
        let sdk;
        let gameStarted = false;
        let gameOver = false;
        let gamePaused = false;
        let sensorConnected = false;

        let level = 1;
        let score = 0;
        let timeRemaining = 60;
        let hintsRemaining = 3;
        let difficulty = 'medium';

        let puzzleGrid = [];
        let gridSize = 3;
        let cellSize = 0;
        let gridOffsetX = 0;
        let gridOffsetY = 0;

        let lastRotationTime = 0;
        let currentTiltX = 0;
        let selectedCell = null;
        let hintActive = false;
        let hintTimeout = null;

        let timerInterval = null;
        let animationFrameId = null;

        // ==================== í¼ì¦ ì¡°ê° í´ë˜ìŠ¤ ====================
        class PuzzlePiece {
            constructor(row, col, type, correctRotation) {
                this.row = row;
                this.col = col;
                this.type = type;
                this.currentRotation = ROTATION_ANGLES[Math.floor(Math.random() * 4)];
                this.correctRotation = correctRotation;
                this.targetRotation = this.currentRotation;
                this.isCorrect = false;
                this.isHighlighted = false;
                this.animationProgress = 0;
            }

            rotate(direction) {
                const currentIndex = ROTATION_ANGLES.indexOf(this.currentRotation);
                let newIndex = direction > 0 ? currentIndex + 1 : currentIndex - 1;
                
                if (newIndex >= ROTATION_ANGLES.length) newIndex = 0;
                if (newIndex < 0) newIndex = ROTATION_ANGLES.length - 1;
                
                this.targetRotation = ROTATION_ANGLES[newIndex];
            }

            update() {
                // ë¶€ë“œëŸ¬ìš´ íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                if (this.currentRotation !== this.targetRotation) {
                    const diff = this.targetRotation - this.currentRotation;
                    const step = diff > 0 ? 15 : -15;
                    
                    if (Math.abs(diff) < Math.abs(step)) {
                        this.currentRotation = this.targetRotation;
                    } else {
                        this.currentRotation += step;
                    }
                    
                    // 360ë„ ìˆœí™˜
                    if (this.currentRotation >= 360) this.currentRotation -= 360;
                    if (this.currentRotation < 0) this.currentRotation += 360;
                }

                // ì •ë‹µ í™•ì¸
                this.isCorrect = (this.currentRotation === this.correctRotation);

                // ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰
                if (this.animationProgress < 1) {
                    this.animationProgress += 0.05;
                }
            }

            draw(ctx, x, y, size) {
                ctx.save();
                ctx.translate(x + size / 2, y + size / 2);
                ctx.rotate((this.currentRotation * Math.PI) / 180);

                // ê·¸ë¦¼ì
                ctx.shadowColor = COLORS.SHADOW;
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                // ë°°ê²½
                const bgColor = this.isCorrect ? COLORS.CORRECT : 
                               this.isHighlighted ? COLORS.WARNING : 
                               COLORS.NEUTRAL;
                
                ctx.fillStyle = bgColor;
                ctx.strokeStyle = COLORS.PRIMARY;
                ctx.lineWidth = 3;

                const pieceSize = size * 0.8;

                // ë„í˜• ê·¸ë¦¬ê¸°
                switch (this.type) {
                    case PUZZLE_TYPES.SQUARE:
                        this.drawSquare(ctx, pieceSize);
                        break;
                    case PUZZLE_TYPES.TRIANGLE:
                        this.drawTriangle(ctx, pieceSize);
                        break;
                    case PUZZLE_TYPES.CIRCLE:
                        this.drawCircle(ctx, pieceSize);
                        break;
                    case PUZZLE_TYPES.DIAMOND:
                        this.drawDiamond(ctx, pieceSize);
                        break;
                    case PUZZLE_TYPES.HEXAGON:
                        this.drawHexagon(ctx, pieceSize);
                        break;
                }

                ctx.restore();

                // ì •ë‹µ í‘œì‹œ
                if (this.isCorrect) {
                    ctx.save();
                    ctx.fillStyle = COLORS.SUCCESS;
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('âœ“', x + size / 2, y + size / 2);
                    ctx.restore();
                }

                // íŒíŠ¸ í‘œì‹œ
                if (this.isHighlighted && hintActive) {
                    ctx.save();
                    ctx.strokeStyle = COLORS.WARNING;
                    ctx.lineWidth = 5;
                    ctx.setLineDash([10, 5]);
                    ctx.strokeRect(x, y, size, size);
                    ctx.restore();
                }
            }

            drawSquare(ctx, size) {
                const half = size / 2;
                ctx.fillRect(-half, -half, size, size);
                ctx.strokeRect(-half, -half, size, size);
                
                // ë°©í–¥ í‘œì‹œ (í™”ì‚´í‘œ)
                ctx.fillStyle = COLORS.PRIMARY;
                ctx.beginPath();
                ctx.moveTo(0, -half + 10);
                ctx.lineTo(-10, -half + 25);
                ctx.lineTo(10, -half + 25);
                ctx.closePath();
                ctx.fill();
            }

            drawTriangle(ctx, size) {
                const height = size * 0.866;
                ctx.beginPath();
                ctx.moveTo(0, -height / 2);
                ctx.lineTo(-size / 2, height / 2);
                ctx.lineTo(size / 2, height / 2);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // ë°©í–¥ í‘œì‹œ (ì )
                ctx.fillStyle = COLORS.PRIMARY;
                ctx.beginPath();
                ctx.arc(0, -height / 2 + 15, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            drawCircle(ctx, size) {
                const radius = size / 2;
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // ë°©í–¥ í‘œì‹œ (ì„ )
                ctx.strokeStyle = COLORS.PRIMARY;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -radius + 10);
                ctx.stroke();
            }

            drawDiamond(ctx, size) {
                const half = size / 2;
                ctx.beginPath();
                ctx.moveTo(0, -half);
                ctx.lineTo(half, 0);
                ctx.lineTo(0, half);
                ctx.lineTo(-half, 0);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // ë°©í–¥ í‘œì‹œ (ì‘ì€ ë‹¤ì´ì•„ëª¬ë“œ)
                ctx.fillStyle = COLORS.PRIMARY;
                ctx.beginPath();
                ctx.moveTo(0, -half + 10);
                ctx.lineTo(8, -half + 18);
                ctx.lineTo(0, -half + 26);
                ctx.lineTo(-8, -half + 18);
                ctx.closePath();
                ctx.fill();
            }

            drawHexagon(ctx, size) {
                const radius = size / 2;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // ë°©í–¥ í‘œì‹œ (ìœ¡ê°í˜•)
                ctx.fillStyle = COLORS.PRIMARY;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    const x = 10 * Math.cos(angle);
                    const y = 10 * Math.sin(angle) - radius + 20;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
            }
        }

        // ==================== SDK ì´ˆê¸°í™” ====================
        function initSDK() {
            console.log('ğŸ® SDK ì´ˆê¸°í™” ì‹œì‘...');
            
            sdk = new SessionSDK({
                gameId: 'twist-match',
                gameType: 'solo'
            });

            // ì„œë²„ ì—°ê²° ì™„ë£Œ
            sdk.on('connected', () => {
                console.log('âœ… ì„œë²„ ì—°ê²° ì™„ë£Œ');
                createSession();
            });

            // ì„¸ì…˜ ìƒì„± ì™„ë£Œ
            sdk.on('session-created', (event) => {
                const session = event.detail || event;
                console.log('âœ… ì„¸ì…˜ ìƒì„±ë¨:', session);

                // ì„¸ì…˜ ì½”ë“œ í‘œì‹œ
                const sessionCodeEl = document.getElementById('session-code');
                if (sessionCodeEl && session.sessionCode) {
                    sessionCodeEl.textContent = session.sessionCode;
                    console.log('ì„¸ì…˜ ì½”ë“œ í‘œì‹œ:', session.sessionCode);
                }

                // QR ì½”ë“œ ìƒì„±
                setTimeout(() => {
                    const qrUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                    console.log('QR URL ìƒì„±:', qrUrl);
                    generateQRCode(qrUrl);
                }, 100);
            });

            // ì„¼ì„œ ì—°ê²°
            sdk.on('sensor-connected', (event) => {
                const data = event.detail || event;
                console.log('âœ… ì„¼ì„œ ì—°ê²°ë¨:', data.sensorId);

                sensorConnected = true;

                // UI ì—…ë°ì´íŠ¸
                const statusEl = document.getElementById('sensor-status');
                statusEl.textContent = 'ì„¼ì„œ ì—°ê²°ë¨ âœ“';
                statusEl.className = 'connected';

                showToastMessage('ğŸ“± ì„¼ì„œê°€ ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤!');

                // ğŸš€ í•„ìˆ˜: ì„¼ì„œ ì—°ê²° 1ì´ˆ í›„ ìë™ ê²Œì„ ì‹œì‘
                setTimeout(() => {
                    if (!gameStarted && !gameOver) {
                        startGame();
                        console.log('ğŸ® ê²Œì„ ìë™ ì‹œì‘ë¨!');
                    }
                }, 1000);
            });

            // ì„¼ì„œ ë°ì´í„° ìˆ˜ì‹ 
            sdk.on('sensor-data', (event) => {
                const data = event.detail || event;
                
                // ê²Œì„ ì˜¤ë²„ê°€ ì•„ë‹ˆë©´ í•­ìƒ ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬
                if (!gameOver) {
                    processSensorData(data);
                }
            });

            // ì„¼ì„œ ì—°ê²° í•´ì œ
            sdk.on('sensor-disconnected', (event) => {
                const data = event.detail || event;
                console.log('âš ï¸ ì„¼ì„œ ì—°ê²° í•´ì œ:', data.sensorId);

                sensorConnected = false;

                // UI ì—…ë°ì´íŠ¸
                const statusEl = document.getElementById('sensor-status');
                statusEl.textContent = 'ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...';
                statusEl.className = 'disconnected';

                showToastMessage('âš ï¸ ì„¼ì„œ ì—°ê²°ì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤');
            });

            // ì—ëŸ¬ ì²˜ë¦¬
            sdk.on('error', (event) => {
                const error = event.detail || event;
                console.error('âŒ SDK ì—ëŸ¬:', error);
                showToastMessage('âŒ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            });
        }

        // ==================== ì„¸ì…˜ ìƒì„± ====================
        function createSession() {
            console.log('ì„¸ì…˜ ìƒì„± ì‹œë„...');
            sdk.createSession().then(session => {
                console.log('âœ… ì„¸ì…˜ ìƒì„± ì„±ê³µ:', session);
            }).catch(error => {
                console.error('âŒ ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨:', error);
                showToastMessage('âŒ ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨: ' + error.message);
            });
        }

        // ==================== QR ì½”ë“œ ìƒì„± ====================
        function generateQRCode(url) {
            const qrContainer = document.getElementById('qr-code');
            if (!qrContainer) return;

            qrContainer.innerHTML = '';

            if (typeof QRCode !== 'undefined') {
                try {
                    new QRCode(qrContainer, {
                        text: url,
                        width: 150,
                        height: 150,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.H
                    });
                    console.log('âœ… QR ì½”ë“œ ìƒì„± ì™„ë£Œ (QRCode.js)');
                } catch (error) {
                    console.error('QRCode.js ìƒì„± ì‹¤íŒ¨:', error);
                    generateQRCodeFallback(qrContainer, url);
                }
            } else {
                console.log('QRCode.js ì—†ìŒ, í´ë°± ì‚¬ìš©');
                generateQRCodeFallback(qrContainer, url);
            }
        }

        function generateQRCodeFallback(container, url) {
            const img = document.createElement('img');
            img.src = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(url)}`;
            img.alt = 'QR Code';
            img.style.width = '150px';
            img.style.height = '150px';
            img.style.borderRadius = '8px';
            container.appendChild(img);
            console.log('âœ… QR ì½”ë“œ ìƒì„± ì™„ë£Œ (í´ë°±)');
        }

        // ==================== ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ====================
        function processSensorData(sensorData) {
            if (!gameStarted || gameOver || gamePaused) return;

            const { orientation, acceleration } = sensorData.data;

            if (orientation) {
                // gamma: ì¢Œìš° ê¸°ìš¸ê¸° (-90 ~ 90)
                const gamma = orientation.gamma || 0;
                currentTiltX = gamma;

                // íšŒì „ ê°ì§€ (ì¿¨ë‹¤ìš´ ì²´í¬)
                const now = Date.now();
                if (now - lastRotationTime > ROTATION_COOLDOWN) {
                    if (Math.abs(gamma) > SENSOR_THRESHOLD) {
                        const direction = gamma > 0 ? 1 : -1;
                        rotateSelectedPiece(direction);
                        lastRotationTime = now;
                    }
                }
            }

            // í”ë“¤ê¸° ê°ì§€ (íŒíŠ¸ í™œì„±í™”)
            if (acceleration) {
                const shake = Math.sqrt(
                    acceleration.x ** 2 +
                    acceleration.y ** 2 +
                    acceleration.z ** 2
                );

                if (shake > 25 && hintsRemaining > 0 && !hintActive) {
                    useHint();
                }
            }
        }

        // ==================== ê²Œì„ ì´ˆê¸°í™” ====================
        function initGame() {
            console.log('ğŸ® ê²Œì„ ì´ˆê¸°í™”...');

            // ìº”ë²„ìŠ¤ ì„¤ì •
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            // ê²Œì„ ë³€ìˆ˜ ì´ˆê¸°í™”
            level = 1;
            score = 0;
            timeRemaining = DIFFICULTY_SETTINGS[difficulty].timeLimit;
            hintsRemaining = 3;
            gameStarted = false;
            gameOver = false;
            gamePaused = false;

            // UI ì—…ë°ì´íŠ¸
            updateUI();

            // í¼ì¦ ìƒì„±
            generatePuzzle();

            // ì˜¤ë²„ë ˆì´ í‘œì‹œ
            showOverlay();

            // íŒíŠ¸ ë²„íŠ¼ ì´ë²¤íŠ¸
            document.getElementById('hint-button').addEventListener('click', useHint);

            console.log('âœ… ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ');
        }

        // ==================== í¼ì¦ ìƒì„± ====================
        function generatePuzzle() {
            puzzleGrid = [];
            gridSize = DIFFICULTY_SETTINGS[difficulty].gridSize;
            
            // ê·¸ë¦¬ë“œ í¬ê¸° ê³„ì‚° (í™”ë©´ì˜ 70% ì‚¬ìš©)
            const maxSize = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.7;
            cellSize = maxSize / gridSize;
            
            // ê·¸ë¦¬ë“œ ì¤‘ì•™ ì •ë ¬
            gridOffsetX = (CANVAS_WIDTH - (cellSize * gridSize)) / 2;
            gridOffsetY = (CANVAS_HEIGHT - (cellSize * gridSize)) / 2;

            // í¼ì¦ ì¡°ê° ìƒì„±
            const types = Object.values(PUZZLE_TYPES);
            
            for (let row = 0; row < gridSize; row++) {
                puzzleGrid[row] = [];
                for (let col = 0; col < gridSize; col++) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    const correctRotation = ROTATION_ANGLES[Math.floor(Math.random() * 4)];
                    const piece = new PuzzlePiece(row, col, type, correctRotation);
                    puzzleGrid[row][col] = piece;
                }
            }

            // ì²« ë²ˆì§¸ ì¡°ê° ì„ íƒ
            selectedCell = { row: 0, col: 0 };
            puzzleGrid[0][0].isHighlighted = true;

            console.log(`âœ… ${gridSize}x${gridSize} í¼ì¦ ìƒì„± ì™„ë£Œ`);
        }

        // ==================== ê²Œì„ ì‹œì‘ ====================
        function startGame() {
            if (gameStarted) return;

            console.log('ğŸš€ ê²Œì„ ì‹œì‘!');
            gameStarted = true;
            gameOver = false;
            gamePaused = false;

            hideOverlay();

            // íƒ€ì´ë¨¸ ì‹œì‘
            startTimer();

            // ê²Œì„ ë£¨í”„ ì‹œì‘
            gameLoop();

            showToastMessage('ğŸ® ê²Œì„ ì‹œì‘!');
        }

        // ==================== íƒ€ì´ë¨¸ ì‹œì‘ ====================
        function startTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
            }

            timerInterval = setInterval(() => {
                if (!gameStarted || gameOver || gamePaused) return;

                timeRemaining--;
                updateUI();

                // ì‹œê°„ ê²½ê³ 
                if (timeRemaining === 10) {
                    showToastMessage('â° 10ì´ˆ ë‚¨ì•˜ìŠµë‹ˆë‹¤!');
                }

                // ì‹œê°„ ì¢…ë£Œ
                if (timeRemaining <= 0) {
                    endGame(false);
                }
            }, 1000);
        }

        // ==================== ì„ íƒëœ ì¡°ê° íšŒì „ ====================
        function rotateSelectedPiece(direction) {
            if (!selectedCell) return;

            const piece = puzzleGrid[selectedCell.row][selectedCell.col];
            piece.rotate(direction);

            // ì‚¬ìš´ë“œ íš¨ê³¼ (ì‹œê°ì  í”¼ë“œë°±)
            showToastMessage(direction > 0 ? 'â†»' : 'â†º', 200);

            // í¼ì¦ ì™„ì„± í™•ì¸
            checkPuzzleComplete();
        }

        // ==================== í¼ì¦ ì™„ì„± í™•ì¸ ====================
        function checkPuzzleComplete() {
            let allCorrect = true;

            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    if (!puzzleGrid[row][col].isCorrect) {
                        allCorrect = false;
                        break;
                    }
                }
                if (!allCorrect) break;
            }

            if (allCorrect) {
                levelComplete();
            }
        }

        // ==================== ë ˆë²¨ ì™„ë£Œ ====================
        function levelComplete() {
            console.log(`ğŸ‰ ë ˆë²¨ ${level} ì™„ë£Œ!`);

            // ì ìˆ˜ ê³„ì‚°
            const timeBonus = timeRemaining * 10;
            const levelBonus = level * 100;
            score += timeBonus + levelBonus;

            // ë ˆë²¨ ì—…
            level++;

            // ë‚œì´ë„ ì¡°ì •
            if (level > 3 && difficulty === 'medium') {
                difficulty = 'hard';
            }

            // UI ì—…ë°ì´íŠ¸
            updateUI();

            // í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ (ì˜¤ë²„ë ˆì´ ì‚¬ìš© ì•ˆí•¨!)
            showToastMessage(`ğŸ‰ ë ˆë²¨ ${level - 1} í´ë¦¬ì–´!\n+${timeBonus + levelBonus}ì `, 2000);

            // ë‹¤ìŒ ë ˆë²¨ ìƒì„±
            setTimeout(() => {
                timeRemaining = DIFFICULTY_SETTINGS[difficulty].timeLimit;
                hintsRemaining = Math.min(hintsRemaining + 1, 5);
                generatePuzzle();
                updateUI();
                showToastMessage(`ë ˆë²¨ ${level} ì‹œì‘!`, 1500);
            }, 2000);
        }

        // ==================== íŒíŠ¸ ì‚¬ìš© ====================
        function useHint() {
            if (hintsRemaining <= 0 || hintActive || !gameStarted || gameOver) {
                return;
            }

            hintsRemaining--;
            hintActive = true;
            updateUI();

            console.log('ğŸ’¡ íŒíŠ¸ ì‚¬ìš©');

            // í‹€ë¦° ì¡°ê° ì°¾ê¸°
            let incorrectPieces = [];
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const piece = puzzleGrid[row][col];
                    if (!piece.isCorrect) {
                        incorrectPieces.push(piece);
                    }
                }
            }

            if (incorrectPieces.length > 0) {
                // ëœë¤ìœ¼ë¡œ í•˜ë‚˜ ì„ íƒ
                const hintPiece = incorrectPieces[Math.floor(Math.random() * incorrectPieces.length)];
                hintPiece.isHighlighted = true;

                // ì„ íƒëœ ì…€ ë³€ê²½
                selectedCell = { row: hintPiece.row, col: hintPiece.col };

                showToastMessage('ğŸ’¡ ì´ ì¡°ê°ì„ ë§ì¶°ë³´ì„¸ìš”!', 1500);

                // íŒíŠ¸ íƒ€ì„ì•„ì›ƒ
                if (hintTimeout) clearTimeout(hintTimeout);
                hintTimeout = setTimeout(() => {
                    hintActive = false;
                    // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
                    for (let row = 0; row < gridSize; row++) {
                        for (let col = 0; col < gridSize; col++) {
                            puzzleGrid[row][col].isHighlighted = false;
                        }
                    }
                    // ì„ íƒëœ ì…€ë§Œ í•˜ì´ë¼ì´íŠ¸
                    if (selectedCell) {
                        puzzleGrid[selectedCell.row][selectedCell.col].isHighlighted = true;
                    }
                }, HINT_DURATION);
            }
        }

        // ==================== ê²Œì„ ì¢…ë£Œ ====================
        function endGame(isWin) {
            console.log(isWin ? 'ğŸ‰ ê²Œì„ ìŠ¹ë¦¬!' : 'ğŸ’€ ê²Œì„ ì˜¤ë²„!');

            gameStarted = false;
            gameOver = true;

            // íƒ€ì´ë¨¸ ì¤‘ì§€
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // ê²Œì„ ë£¨í”„ ì¤‘ì§€
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // ê²°ê³¼ í‘œì‹œ
            setTimeout(() => {
                const overlay = document.getElementById('overlay');
                const title = overlay.querySelector('.overlay-title');
                const message = overlay.querySelector('.overlay-message');
                const button = overlay.querySelector('.overlay-button');

                if (isWin) {
                    title.textContent = 'ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤!';
                    message.innerHTML = `
                        ëª¨ë“  ë ˆë²¨ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤!<br>
                        <br>
                        <strong>ìµœì¢… ì ìˆ˜: ${score}ì </strong><br>
                        <strong>ë„ë‹¬ ë ˆë²¨: ${level}</strong>
                    `;
                } else {
                    title.textContent = 'â° ì‹œê°„ ì¢…ë£Œ!';
                    message.innerHTML = `
                        ì‹œê°„ì´ ë‹¤ ë˜ì—ˆìŠµë‹ˆë‹¤.<br>
                        <br>
                        <strong>ì ìˆ˜: ${score}ì </strong><br>
                        <strong>ë ˆë²¨: ${level}</strong>
                    `;
                }

                button.textContent = 'ë‹¤ì‹œ ì‹œì‘';
                button.onclick = resetGame;

                overlay.classList.remove('hidden');
            }, 500);
        }

        // ==================== ê²Œì„ ë¦¬ì…‹ ====================
        function resetGame() {
            console.log('ğŸ”„ ê²Œì„ ë¦¬ì…‹');

            // ê²Œì„ ë³€ìˆ˜ ì´ˆê¸°í™”
            level = 1;
            score = 0;
            difficulty = 'medium';
            timeRemaining = DIFFICULTY_SETTINGS[difficulty].timeLimit;
            hintsRemaining = 3;
            gameStarted = false;
            gameOver = false;
            gamePaused = false;
            hintActive = false;

            // íƒ€ì´ë¨¸ ì •ë¦¬
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }

            // íŒíŠ¸ íƒ€ì„ì•„ì›ƒ ì •ë¦¬
            if (hintTimeout) {
                clearTimeout(hintTimeout);
                hintTimeout = null;
            }

            // UI ì—…ë°ì´íŠ¸
            updateUI();

            // í¼ì¦ ì¬ìƒì„±
            generatePuzzle();

            // ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
            hideOverlay();

            // ì„¼ì„œ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ ìë™ ì‹œì‘
            if (sensorConnected) {
                setTimeout(() => {
                    startGame();
                }, 1000);
            } else {
                showOverlay();
            }
        }

        // ==================== UI ì—…ë°ì´íŠ¸ ====================
        function updateUI() {
            document.getElementById('level-display').textContent = level;
            document.getElementById('score-display').textContent = score;
            document.getElementById('timer-display').textContent = timeRemaining;
            document.getElementById('hints-display').textContent = hintsRemaining;

            // íŒíŠ¸ ë²„íŠ¼ ìƒíƒœ
            const hintButton = document.getElementById('hint-button');
            hintButton.disabled = hintsRemaining <= 0 || !gameStarted || gameOver;
            hintButton.textContent = `ğŸ’¡ íŒíŠ¸ (${hintsRemaining})`;
        }

        // ==================== í† ìŠ¤íŠ¸ ë©”ì‹œì§€ í‘œì‹œ ====================
        function showToastMessage(message, duration = 1000) {
            const toast = document.getElementById('toast-message');
            toast.textContent = message;
            toast.style.display = 'block';
            toast.style.opacity = '1';

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    toast.style.display = 'none';
                }, 300);
            }, duration);
        }

        // ==================== ì˜¤ë²„ë ˆì´ í‘œì‹œ/ìˆ¨ê¸°ê¸° ====================
        function showOverlay() {
            const overlay = document.getElementById('overlay');
            const title = overlay.querySelector('.overlay-title');
            const message = overlay.querySelector('.overlay-message');
            const button = overlay.querySelector('.overlay-button');

            title.textContent = 'Twist & Match';
            message.innerHTML = `
                ê¸°ê¸°ë¥¼ íšŒì „ì‹œì¼œ í¼ì¦ ì¡°ê°ì„ ë§ì¶”ì„¸ìš”!<br>
                <br>
                <strong>ì¡°ì‘ ë°©ë²•:</strong><br>
                ğŸ“± ê¸°ê¸°ë¥¼ ì¢Œìš°ë¡œ ê¸°ìš¸ì´ë©´ í¼ì¦ì´ íšŒì „í•©ë‹ˆë‹¤<br>
                ğŸ¯ ëª¨ë“  ì¡°ê°ì„ ì˜¬ë°”ë¥¸ ë°©í–¥ìœ¼ë¡œ ë§ì¶”ì„¸ìš”<br>
                â±ï¸ ì œí•œ ì‹œê°„ ë‚´ì— í¼ì¦ì„ ì™„ì„±í•˜ì„¸ìš”<br>
                ğŸ’¡ í”ë“¤ì–´ì„œ íŒíŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
            `;
            button.textContent = 'ì‹œì‘í•˜ê¸°';
            button.onclick = () => {
                hideOverlay();
                if (sensorConnected && !gameStarted) {
                    startGame();
                }
            };

            overlay.classList.remove('hidden');
        }

        function hideOverlay() {
            document.getElementById('overlay').classList.add('hidden');
        }

        // ==================== ê²Œì„ ë£¨í”„ ====================
        function gameLoop() {
            if (gameOver) return;

            // ì—…ë°ì´íŠ¸
            updateGame();

            // ë Œë”ë§
            renderGame();

            // ë‹¤ìŒ í”„ë ˆì„
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ==================== ê²Œì„ ì—…ë°ì´íŠ¸ ====================
        function updateGame() {
            if (!gameStarted || gameOver || gamePaused) return;

            // í¼ì¦ ì¡°ê° ì—…ë°ì´íŠ¸
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    puzzleGrid[row][col].update();
                }
            }

            // ì„ íƒëœ ì…€ ìë™ ì´ë™ (ì„¼ì„œ ê¸°ìš¸ê¸°ì— ë”°ë¼)
            if (selectedCell && Math.abs(currentTiltX) < SENSOR_THRESHOLD) {
                // ê¸°ìš¸ê¸°ê°€ ì‘ì„ ë•ŒëŠ” ë‹¤ìŒ ì¡°ê°ìœ¼ë¡œ ìë™ ì´ë™
                const totalCells = gridSize * gridSize;
                const currentIndex = selectedCell.row * gridSize + selectedCell.col;
                const nextIndex = (currentIndex + 1) % totalCells;
                const nextRow = Math.floor(nextIndex / gridSize);
                const nextCol = nextIndex % gridSize;

                // ì´ì „ ì„ íƒ í•´ì œ
                puzzleGrid[selectedCell.row][selectedCell.col].isHighlighted = false;

                // ìƒˆë¡œìš´ ì„ íƒ
                selectedCell = { row: nextRow, col: nextCol };
                puzzleGrid[nextRow][nextCol].isHighlighted = true;
            }
        }

        // ==================== ê²Œì„ ë Œë”ë§ ====================
        function renderGame() {
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            const gradient = ctx.createLinearGradient(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // ê·¸ë¦¬ë“œ ë°°ê²½
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.fillRect(
                gridOffsetX - 10,
                gridOffsetY - 10,
                cellSize * gridSize + 20,
                cellSize * gridSize + 20
            );

            // ê·¸ë¦¬ë“œ ì„ 
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i <= gridSize; i++) {
                // ì„¸ë¡œì„ 
                ctx.beginPath();
                ctx.moveTo(gridOffsetX + i * cellSize, gridOffsetY);
                ctx.lineTo(gridOffsetX + i * cellSize, gridOffsetY + cellSize * gridSize);
                ctx.stroke();

                // ê°€ë¡œì„ 
                ctx.beginPath();
                ctx.moveTo(gridOffsetX, gridOffsetY + i * cellSize);
                ctx.lineTo(gridOffsetX + cellSize * gridSize, gridOffsetY + i * cellSize);
                ctx.stroke();
            }

            // í¼ì¦ ì¡°ê° ê·¸ë¦¬ê¸°
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    const piece = puzzleGrid[row][col];
                    const x = gridOffsetX + col * cellSize;
                    const y = gridOffsetY + row * cellSize;
                    piece.draw(ctx, x, y, cellSize);
                }
            }

            // ì„¼ì„œ ê¸°ìš¸ê¸° í‘œì‹œ (ë””ë²„ê·¸)
            if (gameStarted && !gameOver) {
                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(
                    `ê¸°ìš¸ê¸°: ${currentTiltX.toFixed(1)}Â°`,
                    CANVAS_WIDTH / 2,
                    CANVAS_HEIGHT - 30
                );
                ctx.restore();

                // ê¸°ìš¸ê¸° ë°”
                const barWidth = 200;
                const barHeight = 20;
                const barX = (CANVAS_WIDTH - barWidth) / 2;
                const barY = CANVAS_HEIGHT - 60;

                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                const tiltPercent = Math.max(-1, Math.min(1, currentTiltX / 90));
                const indicatorX = barX + barWidth / 2 + (tiltPercent * barWidth / 2);

                ctx.fillStyle = Math.abs(currentTiltX) > SENSOR_THRESHOLD ? 
                               COLORS.WARNING : COLORS.SUCCESS;
                ctx.fillRect(indicatorX - 3, barY - 5, 6, barHeight + 10);
            }

            // ê²Œì„ ì‹œì‘ ì „ ë©”ì‹œì§€
            if (!gameStarted && !gameOver && sensorConnected) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                ctx.fillStyle = 'white';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ê¸°ê¸°ë¥¼ ê¸°ìš¸ì—¬ì„œ ì‹œì‘í•˜ì„¸ìš”!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                ctx.restore();
            }
        }

        // ==================== ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬ ====================
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // ê·¸ë¦¬ë“œ í¬ê¸° ì¬ê³„ì‚°
            const maxSize = Math.min(canvas.width, canvas.height) * 0.7;
            cellSize = maxSize / gridSize;
            gridOffsetX = (canvas.width - (cellSize * gridSize)) / 2;
            gridOffsetY = (canvas.height - (cellSize * gridSize)) / 2;
        });

        // ==================== í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™” ====================
        window.addEventListener('load', () => {
            console.log('ğŸ® Twist & Match ê²Œì„ ë¡œë”©...');
            
            // SDK ì´ˆê¸°í™”
            initSDK();
            
            // ê²Œì„ ì´ˆê¸°í™”
            initGame();
            
            console.log('âœ… ê²Œì„ ë¡œë”© ì™„ë£Œ!');
        });

        // ==================== í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬ ====================
        window.addEventListener('beforeunload', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (hintTimeout) {
                clearTimeout(hintTimeout);
            }
        });

        // ==================== ë””ë²„ê·¸ í•¨ìˆ˜ (ê°œë°œìš©) ====================
        window.debugGame = {
            skipLevel: () => {
                levelComplete();
            },
            addTime: (seconds) => {
                timeRemaining += seconds;
                updateUI();
            },
            addHints: (count) => {
                hintsRemaining += count;
                updateUI();
            },
            solveAll: () => {
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const piece = puzzleGrid[row][col];
                        piece.currentRotation = piece.correctRotation;
                        piece.targetRotation = piece.correctRotation;
                    }
                }
                checkPuzzleComplete();
            },
            showInfo: () => {
                console.log({
                    level,
                    score,
                    timeRemaining,
                    hintsRemaining,
                    gridSize,
                    difficulty,
                    gameStarted,
                    gameOver,
                    sensorConnected
                });
            }
        };

        console.log('ğŸ’¡ ë””ë²„ê·¸ ëª…ë ¹ì–´: window.debugGame.showInfo()');
    </script>
</body>
</html>