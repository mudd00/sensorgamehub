<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì„¼ì„œ ë³¼ ê²Œì„ - Sensor Game Hub</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-header h1 {
            color: #667eea;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .game-header p {
            color: #666;
            font-size: 1.1em;
        }

        .main-content {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .session-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 25px;
            color: white;
            min-width: 280px;
            max-width: 350px;
            flex: 1;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .session-panel h2 {
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
        }

        .session-info {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .session-info label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 5px;
            opacity: 0.9;
        }

        #session-code {
            font-size: 2em;
            font-weight: bold;
            letter-spacing: 3px;
            display: block;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            margin-top: 5px;
        }

        #qr-code {
            background: white;
            border-radius: 10px;
            padding: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 230px;
            margin-bottom: 20px;
        }

        #qr-code img, #qr-code canvas {
            max-width: 200px;
            max-height: 200px;
            border-radius: 5px;
        }

        .sensor-status-container {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }

        #sensor-status {
            font-size: 1.1em;
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        #sensor-status.disconnected {
            background: rgba(255, 107, 107, 0.3);
            color: #fff;
        }

        #sensor-status.connected {
            background: rgba(46, 213, 115, 0.3);
            color: #fff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .game-area {
            flex: 2;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            text-align: center;
            flex: 1;
            min-width: 100px;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .stat-box label {
            display: block;
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .stat-box .value {
            font-size: 1.8em;
            font-weight: bold;
        }

        .canvas-container {
            position: relative;
            background: #1a1a2e;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: auto;
            max-height: 600px;
        }

        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .game-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .game-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-overlay p {
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        .game-overlay button {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .game-overlay button:hover {
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(102, 126, 234, 0.6);
        }

        .game-overlay button:active {
            transform: translateY(0);
        }

        .controls-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            text-align: center;
        }

        .controls-info h3 {
            margin-bottom: 10px;
            color: #667eea;
        }

        .controls-info p {
            color: #666;
            line-height: 1.6;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: particleFloat 1s ease-out forwards;
        }

        @keyframes particleFloat {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }

            .game-header h1 {
                font-size: 1.8em;
            }

            .main-content {
                flex-direction: column;
            }

            .session-panel {
                max-width: 100%;
            }

            .stat-box {
                min-width: 80px;
                padding: 10px 15px;
            }

            .stat-box .value {
                font-size: 1.4em;
            }
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction-banner {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .instruction-banner strong {
            font-size: 1.2em;
            display: block;
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸ® ì„¼ì„œ ë³¼ ê²Œì„</h1>
            <p>ìŠ¤ë§ˆíŠ¸í°ì„ ê¸°ìš¸ì—¬ì„œ íŒ¨ë“¤ì„ ì›€ì§ì´ê³  ë²½ëŒì„ ëª¨ë‘ ê¹¨ì„¸ìš”!</p>
        </div>

        <div class="main-content">
            <!-- ì„¸ì…˜ íŒ¨ë„ -->
            <div class="session-panel">
                <h2>ğŸ“± ì„¼ì„œ ì—°ê²°</h2>
                
                <div class="session-info">
                    <label>ì„¸ì…˜ ì½”ë“œ</label>
                    <span id="session-code">---</span>
                </div>

                <div id="qr-code">
                    <div class="loading"></div>
                </div>

                <div class="sensor-status-container">
                    <label>ì„¼ì„œ ìƒíƒœ</label>
                    <div id="sensor-status" class="disconnected">
                        ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...
                    </div>
                </div>

                <div class="controls-info">
                    <h3>ğŸ¯ ì¡°ì‘ ë°©ë²•</h3>
                    <p>
                        ğŸ“± <strong>ì¢Œìš° ê¸°ìš¸ì´ê¸°</strong>: íŒ¨ë“¤ ì´ë™<br>
                        ğŸ“³ <strong>í”ë“¤ê¸°</strong>: ê²Œì„ ì‹œì‘<br>
                        ğŸ¯ <strong>ëª©í‘œ</strong>: ëª¨ë“  ë²½ëŒ íŒŒê´´!
                    </p>
                </div>
            </div>

            <!-- ê²Œì„ ì˜ì—­ -->
            <div class="game-area">
                <div class="game-stats">
                    <div class="stat-box">
                        <label>ì ìˆ˜</label>
                        <div class="value" id="score-display">0</div>
                    </div>
                    <div class="stat-box">
                        <label>ìƒëª…</label>
                        <div class="value" id="lives-display">3</div>
                    </div>
                    <div class="stat-box">
                        <label>ë ˆë²¨</label>
                        <div class="value" id="level-display">1</div>
                    </div>
                    <div class="stat-box">
                        <label>ë²½ëŒ</label>
                        <div class="value" id="bricks-display">0</div>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="gameCanvas" width="800" height="600"></canvas>
                    
                    <div class="game-overlay active" id="game-overlay">
                        <h2 id="overlay-title">ì„¼ì„œë¥¼ ì—°ê²°í•˜ì„¸ìš”!</h2>
                        <p id="overlay-message">QR ì½”ë“œë¥¼ ìŠ¤ìº”í•˜ì—¬ ìŠ¤ë§ˆíŠ¸í°ì„ ì—°ê²°í•˜ì„¸ìš”</p>
                        <p id="overlay-submessage">ì—°ê²° í›„ í”ë“¤ì–´ì„œ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”</p>
                    </div>
                </div>

                <div class="instruction-banner" id="instruction-banner" style="display: none;">
                    <strong>ğŸ® ê²Œì„ ì‹œì‘!</strong>
                    ìŠ¤ë§ˆíŠ¸í°ì„ í”ë“¤ê±°ë‚˜ í™”ë©´ì„ í´ë¦­í•˜ì„¸ìš”
                </div>
            </div>
        </div>
    </div>

    <!-- í•„ìˆ˜ ìŠ¤í¬ë¦½íŠ¸ -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/SessionSDK.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>

    <script>
        // ==================== ê²Œì„ ìƒìˆ˜ ì •ì˜ ====================
        const GAME_CONFIG = {
            // ìº”ë²„ìŠ¤ ì„¤ì •
            CANVAS_WIDTH: 800,
            CANVAS_HEIGHT: 600,
            
            // íŒ¨ë“¤ ì„¤ì •
            PADDLE_WIDTH: 120,
            PADDLE_HEIGHT: 20,
            PADDLE_SPEED: 8,
            PADDLE_Y_OFFSET: 50,
            
            // ê³µ ì„¤ì •
            BALL_RADIUS: 10,
            BALL_INITIAL_SPEED: 5,
            BALL_MAX_SPEED: 12,
            BALL_SPEED_INCREMENT: 0.3,
            
            // ë²½ëŒ ì„¤ì •
            BRICK_ROWS: 5,
            BRICK_COLS: 8,
            BRICK_WIDTH: 90,
            BRICK_HEIGHT: 30,
            BRICK_PADDING: 10,
            BRICK_OFFSET_TOP: 60,
            BRICK_OFFSET_LEFT: 35,
            
            // ê²Œì„ ì„¤ì •
            INITIAL_LIVES: 3,
            POINTS_PER_BRICK: 10,
            SHAKE_THRESHOLD: 20,
            TILT_SENSITIVITY: 15,
            
            // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
            COLORS: {
                paddle: '#667eea',
                ball: '#f5576c',
                bricks: [
                    '#ff6b6b', '#ee5a6f', '#f06595', '#cc5de8', '#845ef7',
                    '#5c7cfa', '#339af0', '#22b8cf', '#20c997', '#51cf66',
                    '#94d82d', '#fcc419', '#ff922b', '#ff6b6b', '#f06595'
                ],
                background: '#1a1a2e',
                text: '#ffffff'
            }
        };

        // ==================== ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ====================
        let canvas, ctx;
        let gameStarted = false;
        let gamePaused = false;
        let gameOver = false;
        let sensorConnected = false;
        let animationFrameId = null;

        // ê²Œì„ ì˜¤ë¸Œì íŠ¸
        let paddle = {
            x: 0,
            y: 0,
            width: GAME_CONFIG.PADDLE_WIDTH,
            height: GAME_CONFIG.PADDLE_HEIGHT,
            speed: GAME_CONFIG.PADDLE_SPEED,
            targetX: 0
        };

        let ball = {
            x: 0,
            y: 0,
            radius: GAME_CONFIG.BALL_RADIUS,
            dx: 0,
            dy: 0,
            speed: GAME_CONFIG.BALL_INITIAL_SPEED,
            stuck: true
        };

        // ê²Œì„ í†µê³„
        let score = 0;
        let lives = GAME_CONFIG.INITIAL_LIVES;
        let level = 1;
        let bricks = [];
        let bricksRemaining = 0;

        // ì„¼ì„œ ë°ì´í„°
        let currentTilt = 0;
        let lastShakeTime = 0;

        // íŒŒí‹°í´ íš¨ê³¼
        let particles = [];

        // ==================== SessionSDK ì´ˆê¸°í™” ====================
        const sdk = new SessionSDK({
            gameId: 'ì„¼ì„œ ë³¼ ê²Œì„',
            gameType: 'solo'
        });

        // ==================== SDK ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ====================
        sdk.on('connected', () => {
            console.log('âœ… ì„œë²„ ì—°ê²° ì™„ë£Œ');
            createSession();
        });

        sdk.on('session-created', (event) => {
            const session = event.detail || event;
            console.info('âœ… ì„¸ì…˜ ìƒì„± ì™„ë£Œ:', session);

            // ì„¸ì…˜ ì½”ë“œ í‘œì‹œ
            const sessionCodeEl = document.getElementById('session-code');
            if (sessionCodeEl && session.sessionCode) {
                sessionCodeEl.textContent = session.sessionCode;
                console.info('ì„¸ì…˜ ì½”ë“œ í‘œì‹œ:', session.sessionCode);
            }

            // QR ì½”ë“œ ìƒì„±
            setTimeout(() => {
                const qrUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                console.info('QR URL ìƒì„±:', qrUrl);
                generateQRCode(qrUrl);
            }, 100);
        });

        sdk.on('sensor-connected', (event) => {
            const data = event.detail || event;
            console.log('âœ… ì„¼ì„œ ì—°ê²°ë¨:', data.sensorId);

            sensorConnected = true;

            // UI ì—…ë°ì´íŠ¸
            const statusEl = document.getElementById('sensor-status');
            statusEl.textContent = 'ì„¼ì„œ ì—°ê²°ë¨ âœ“';
            statusEl.className = 'connected';

            // ì˜¤ë²„ë ˆì´ ì—…ë°ì´íŠ¸
            const overlay = document.getElementById('game-overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const overlaySubmessage = document.getElementById('overlay-submessage');

            overlayTitle.textContent = 'ì¤€ë¹„ ì™„ë£Œ!';
            overlayMessage.textContent = 'ìŠ¤ë§ˆíŠ¸í°ì„ í”ë“¤ì–´ì„œ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”';
            overlaySubmessage.textContent = 'ë˜ëŠ” í™”ë©´ì„ í´ë¦­í•˜ì„¸ìš”';

            // ì•ˆë‚´ ë°°ë„ˆ í‘œì‹œ
            const banner = document.getElementById('instruction-banner');
            banner.style.display = 'block';

            // ìë™ ì‹œì‘ íƒ€ì´ë¨¸ (3ì´ˆ í›„)
            setTimeout(() => {
                if (!gameStarted && !gameOver && sensorConnected) {
                    console.log('ğŸ® ìë™ ê²Œì„ ì‹œì‘');
                    startGame();
                }
            }, 3000);
        });

        sdk.on('sensor-disconnected', (event) => {
            const data = event.detail || event;
            console.log('âš ï¸ ì„¼ì„œ ì—°ê²° í•´ì œ:', data.sensorId);

            sensorConnected = false;

            // UI ì—…ë°ì´íŠ¸
            const statusEl = document.getElementById('sensor-status');
            statusEl.textContent = 'ì„¼ì„œ ì—°ê²° ëŒ€ê¸° ì¤‘...';
            statusEl.className = 'disconnected';

            // ê²Œì„ ì¼ì‹œì •ì§€
            if (gameStarted && !gameOver) {
                gamePaused = true;
                const overlay = document.getElementById('game-overlay');
                const overlayTitle = document.getElementById('overlay-title');
                const overlayMessage = document.getElementById('overlay-message');
                
                overlayTitle.textContent = 'ì¼ì‹œì •ì§€';
                overlayMessage.textContent = 'ì„¼ì„œ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤';
                overlay.classList.add('active');
            }
        });

        sdk.on('sensor-data', (event) => {
            const data = event.detail || event;
            processSensorData(data);
        });

        // ==================== ì„¸ì…˜ ìƒì„± í•¨ìˆ˜ ====================
        function createSession() {
            sdk.createSession().then(session => {
                console.log('âœ… ì„¸ì…˜ ìƒì„±ë¨:', session);
            }).catch(error => {
                console.error('âŒ ì„¸ì…˜ ìƒì„± ì‹¤íŒ¨:', error);
                alert('ì„¸ì…˜ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
            });
        }

        // ==================== QR ì½”ë“œ ìƒì„± í•¨ìˆ˜ ====================
        function generateQRCode(url) {
            const qrContainer = document.getElementById('qr-code');
            qrContainer.innerHTML = '';

            if (typeof QRCode !== 'undefined') {
                try {
                    new QRCode(qrContainer, {
                        text: url,
                        width: 200,
                        height: 200,
                        colorDark: '#000000',
                        colorLight: '#ffffff',
                        correctLevel: QRCode.CorrectLevel.H
                    });
                    console.log('âœ… QR ì½”ë“œ ìƒì„± ì™„ë£Œ (QRCode.js)');
                } catch (error) {
                    console.error('QRCode.js ì˜¤ë¥˜:', error);
                    generateQRCodeFallback(url, qrContainer);
                }
            } else {
                console.log('âš ï¸ QRCode.js ì—†ìŒ, í´ë°± ì‚¬ìš©');
                generateQRCodeFallback(url, qrContainer);
            }
        }

        function generateQRCodeFallback(url, container) {
            const img = document.createElement('img');
            img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}`;
            img.alt = 'QR Code';
            img.style.width = '200px';
            img.style.height = '200px';
            container.appendChild(img);
            console.log('âœ… QR ì½”ë“œ ìƒì„± ì™„ë£Œ (í´ë°± API)');
        }

        // ==================== ì„¼ì„œ ë°ì´í„° ì²˜ë¦¬ ====================
        function processSensorData(sensorData) {
            if (!sensorData || !sensorData.data) return;

            const { orientation, acceleration } = sensorData.data;

            // ì¢Œìš° ê¸°ìš¸ê¸°ë¡œ íŒ¨ë“¤ ì´ë™ (gamma: -90 ~ 90)
            if (orientation && orientation.gamma !== null) {
                // gamma ê°’ì„ -1 ~ 1ë¡œ ì •ê·œí™”
                let tiltValue = orientation.gamma / 90;
                
                // ë¯¼ê°ë„ ì¡°ì • ë° ë²”ìœ„ ì œí•œ
                tiltValue = Math.max(-1, Math.min(1, tiltValue));
                
                // íŒ¨ë“¤ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                currentTilt = tiltValue;
                const centerX = canvas.width / 2;
                const maxOffset = (canvas.width / 2) - (paddle.width / 2);
                paddle.targetX = centerX + (tiltValue * maxOffset * (GAME_CONFIG.TILT_SENSITIVITY / 10));
                
                // ë²”ìœ„ ì œí•œ
                paddle.targetX = Math.max(paddle.width / 2, Math.min(canvas.width - paddle.width / 2, paddle.targetX));
            }

            // í”ë“¤ê¸° ê°ì§€ë¡œ ê²Œì„ ì‹œì‘
            if (acceleration) {
                const shake = Math.sqrt(
                    Math.pow(acceleration.x || 0, 2) +
                    Math.pow(acceleration.y || 0, 2) +
                    Math.pow(acceleration.z || 0, 2)
                );

                const currentTime = Date.now();
                
                // í”ë“¤ê¸°ë¡œ ê²Œì„ ì‹œì‘
                if (!gameStarted && shake > GAME_CONFIG.SHAKE_THRESHOLD && 
                    sensorConnected && !gameOver && 
                    currentTime - lastShakeTime > 1000) {
                    
                    lastShakeTime = currentTime;
                    console.log('ğŸ”¥ í”ë“¤ê¸° ê°ì§€! ê²Œì„ ì‹œì‘');
                    startGame();
                }

                // ê²Œì„ ì˜¤ë²„ í›„ í”ë“¤ê¸°ë¡œ ì¬ì‹œì‘
                if (gameOver && shake > GAME_CONFIG.SHAKE_THRESHOLD && 
                    currentTime - lastShakeTime > 1000) {
                    
                    lastShakeTime = currentTime;
                    console.log('ğŸ”¥ í”ë“¤ê¸° ê°ì§€! ê²Œì„ ì¬ì‹œì‘');
                    resetGame();
                }
            }
        }

        // ==================== ê²Œì„ ì´ˆê¸°í™” ====================
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // íŒ¨ë“¤ ì´ˆê¸° ìœ„ì¹˜
            paddle.x = canvas.width / 2;
            paddle.y = canvas.height - GAME_CONFIG.PADDLE_Y_OFFSET;
            paddle.targetX = paddle.x;

            // ê³µ ì´ˆê¸° ìœ„ì¹˜ (íŒ¨ë“¤ ìœ„ì— ë¶™ì–´ìˆìŒ)
            resetBall();

            // ë²½ëŒ ìƒì„±
            createBricks();

            // UI ì—…ë°ì´íŠ¸
            updateUI();

            // í´ë¦­ìœ¼ë¡œ ê²Œì„ ì‹œì‘
            canvas.addEventListener('click', () => {
                if (!gameStarted && !gameOver && sensorConnected) {
                    startGame();
                } else if (gameOver) {
                    resetGame();
                }
            });

            // ê²Œì„ ë£¨í”„ ì‹œì‘
            gameLoop();

            console.log('âœ… ê²Œì„ ì´ˆê¸°í™” ì™„ë£Œ');
        }

        // ==================== ìº”ë²„ìŠ¤ ë¦¬ì‚¬ì´ì¦ˆ ====================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            const aspectRatio = GAME_CONFIG.CANVAS_HEIGHT / GAME_CONFIG.CANVAS_WIDTH;
            
            canvas.style.width = '100%';
            canvas.style.height = (containerWidth * aspectRatio) + 'px';
        }

        // ==================== ë²½ëŒ ìƒì„± ====================
        function createBricks() {
            bricks = [];
            bricksRemaining = 0;

            for (let row = 0; row < GAME_CONFIG.BRICK_ROWS; row++) {
                bricks[row] = [];
                for (let col = 0; col < GAME_CONFIG.BRICK_COLS; col++) {
                    const brick = {
                        x: col * (GAME_CONFIG.BRICK_WIDTH + GAME_CONFIG.BRICK_PADDING) + GAME_CONFIG.BRICK_OFFSET_LEFT,
                        y: row * (GAME_CONFIG.BRICK_HEIGHT + GAME_CONFIG.BRICK_PADDING) + GAME_CONFIG.BRICK_OFFSET_TOP,
                        width: GAME_CONFIG.BRICK_WIDTH,
                        height: GAME_CONFIG.BRICK_HEIGHT,
                        status: 1,
                        color: GAME_CONFIG.COLORS.bricks[row % GAME_CONFIG.COLORS.bricks.length],
                        points: GAME_CONFIG.POINTS_PER_BRICK * (GAME_CONFIG.BRICK_ROWS - row)
                    };
                    bricks[row][col] = brick;
                    bricksRemaining++;
                }
            }

            updateUI();
        }

        // ==================== ê²Œì„ ì‹œì‘ ====================
        function startGame() {
            if (gameStarted || !sensorConnected) return;

            gameStarted = true;
            gamePaused = false;
            ball.stuck = false;

            // ê³µì— ì´ˆê¸° ì†ë„ ë¶€ì—¬ (ìœ„ìª½ ëŒ€ê°ì„ )
            const angle = -60 + (Math.random() * 60 - 30); // -75ë„ ~ -45ë„
            const radians = angle * Math.PI / 180;
            ball.dx = ball.speed * Math.sin(radians);
            ball.dy = -ball.speed * Math.cos(radians);

            // ì˜¤ë²„ë ˆì´ ìˆ¨ê¸°ê¸°
            const overlay = document.getElementById('game-overlay');
            overlay.classList.remove('active');

            // ì•ˆë‚´ ë°°ë„ˆ ìˆ¨ê¸°ê¸°
            const banner = document.getElementById('instruction-banner');
            banner.style.display = 'none';

            console.log('ğŸ® ê²Œì„ ì‹œì‘!', { dx: ball.dx, dy: ball.dy });
        }

        // ==================== ê³µ ë¦¬ì…‹ ====================
        function resetBall() {
            ball.stuck = true;
            ball.x = paddle.x;
            ball.y = paddle.y - ball.radius - 5;
            ball.dx = 0;
            ball.dy = 0;
            ball.speed = GAME_CONFIG.BALL_INITIAL_SPEED;
        }

        // ==================== ê²Œì„ ë£¨í”„ ====================
        function gameLoop() {
            updateGame();
            renderGame();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ==================== ê²Œì„ ì—…ë°ì´íŠ¸ ====================
        function updateGame() {
            if (!gameStarted || gamePaused || gameOver) {
                // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ì¼ì‹œì •ì§€ ìƒíƒœ
                if (ball.stuck) {
                    // ê³µì´ íŒ¨ë“¤ì— ë¶™ì–´ìˆì„ ë•Œ íŒ¨ë“¤ ë”°ë¼ ì´ë™
                    ball.x = paddle.x;
                    ball.y = paddle.y - ball.radius - 5;
                }
                
                // íŒ¨ë“¤ì€ ì„¼ì„œ ì…ë ¥ì— ë”°ë¼ ë¶€ë“œëŸ½ê²Œ ì´ë™
                updatePaddle();
                return;
            }

            // íŒ¨ë“¤ ì—…ë°ì´íŠ¸
            updatePaddle();

            // ê³µì´ ë¶™ì–´ìˆì§€ ì•Šì„ ë•Œë§Œ ì´ë™
            if (!ball.stuck) {
                // ê³µ ì´ë™
                ball.x += ball.dx;
                ball.y += ball.dy;

                // ë²½ ì¶©ëŒ (ì¢Œìš°)
                if (ball.x - ball.radius <= 0 || ball.x + ball.radius >= canvas.width) {
                    ball.dx = -ball.dx;
                    ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
                    createParticles(ball.x, ball.y, '#ffffff', 5);
                }

                // ë²½ ì¶©ëŒ (ìœ„)
                if (ball.y - ball.radius <= 0) {
                    ball.dy = -ball.dy;
                    ball.y = ball.radius;
                    createParticles(ball.x, ball.y, '#ffffff', 5);
                }

                // íŒ¨ë“¤ ì¶©ëŒ
                if (checkPaddleCollision()) {
                    // ê³µì´ íŒ¨ë“¤ ì–´ë””ì— ë§ì•˜ëŠ”ì§€ì— ë”°ë¼ ë°˜ì‚¬ê° ì¡°ì •
                    const hitPos = (ball.x - paddle.x) / paddle.width; // 0 ~ 1
                    const angle = (hitPos - 0.5) * 120; // -60ë„ ~ 60ë„
                    const radians = angle * Math.PI / 180;
                    
                    const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                    ball.dx = speed * Math.sin(radians);
                    ball.dy = -Math.abs(speed * Math.cos(radians)); // í•­ìƒ ìœ„ë¡œ
                    
                    // ì†ë„ ì¦ê°€ (ìµœëŒ€ ì†ë„ ì œí•œ)
                    if (ball.speed < GAME_CONFIG.BALL_MAX_SPEED) {
                        ball.speed += GAME_CONFIG.BALL_SPEED_INCREMENT;
                        const currentSpeed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                        ball.dx = (ball.dx / currentSpeed) * ball.speed;
                        ball.dy = (ball.dy / currentSpeed) * ball.speed;
                    }

                    createParticles(ball.x, ball.y, GAME_CONFIG.COLORS.paddle, 8);
                }

                // ë²½ëŒ ì¶©ëŒ
                checkBrickCollision();

                // ê³µì´ ì•„ë˜ë¡œ ë–¨ì–´ì§
                if (ball.y - ball.radius > canvas.height) {
                    lives--;
                    updateUI();
                    createParticles(ball.x, canvas.height, GAME_CONFIG.COLORS.ball, 15);

                    if (lives <= 0) {
                        // ê²Œì„ ì˜¤ë²„
                        endGame(false);
                    } else {
                        // ê³µ ë¦¬ì…‹
                        resetBall();
                        gameStarted = false;
                        
                        // ì ì‹œ í›„ ìë™ ì¬ì‹œì‘
                        setTimeout(() => {
                            if (!gameOver && sensorConnected) {
                                startGame();
                            }
                        }, 1000);
                    }
                }

                // ëª¨ë“  ë²½ëŒ íŒŒê´´ ì‹œ ë ˆë²¨ í´ë¦¬ì–´
                if (bricksRemaining <= 0) {
                    levelComplete();
                }
            }

            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            updateParticles();
        }

        // ==================== íŒ¨ë“¤ ì—…ë°ì´íŠ¸ ====================
        function updatePaddle() {
            // ë¶€ë“œëŸ¬ìš´ ì´ë™ (ì„ í˜• ë³´ê°„)
            const dx = paddle.targetX - paddle.x;
            paddle.x += dx * 0.2; // 20% ì”© ì´ë™ (ë¶€ë“œëŸ¬ìš´ íš¨ê³¼)

            // ë²”ìœ„ ì œí•œ
            paddle.x = Math.max(paddle.width / 2, Math.min(canvas.width - paddle.width / 2, paddle.x));
        }

        // ==================== íŒ¨ë“¤ ì¶©ëŒ ê°ì§€ ====================
        function checkPaddleCollision() {
            // ê³µì´ íŒ¨ë“¤ ì˜ì—­ì— ìˆëŠ”ì§€ í™•ì¸
            if (ball.y + ball.radius >= paddle.y &&
                ball.y + ball.radius <= paddle.y + paddle.height &&
                ball.x >= paddle.x - paddle.width / 2 &&
                ball.x <= paddle.x + paddle.width / 2 &&
                ball.dy > 0) { // ì•„ë˜ë¡œ ì´ë™ ì¤‘ì¼ ë•Œë§Œ
                
                ball.y = paddle.y - ball.radius; // ê³µì„ íŒ¨ë“¤ ìœ„ë¡œ
                return true;
            }
            return false;
        }

        // ==================== ë²½ëŒ ì¶©ëŒ ê°ì§€ ====================
        function checkBrickCollision() {
            for (let row = 0; row < GAME_CONFIG.BRICK_ROWS; row++) {
                for (let col = 0; col < GAME_CONFIG.BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    
                    if (brick.status === 1) {
                        // AABB ì¶©ëŒ ê°ì§€
                        if (ball.x + ball.radius > brick.x &&
                            ball.x - ball.radius < brick.x + brick.width &&
                            ball.y + ball.radius > brick.y &&
                            ball.y - ball.radius < brick.y + brick.height) {
                            
                            // ì¶©ëŒ ë°©í–¥ ê³„ì‚°
                            const ballCenterX = ball.x;
                            const ballCenterY = ball.y;
                            const brickCenterX = brick.x + brick.width / 2;
                            const brickCenterY = brick.y + brick.height / 2;
                            
                            const dx = ballCenterX - brickCenterX;
                            const dy = ballCenterY - brickCenterY;
                            
                            const width = (brick.width + ball.radius * 2) / 2;
                            const height = (brick.height + ball.radius * 2) / 2;
                            
                            const crossWidth = width * dy;
                            const crossHeight = height * dx;
                            
                            // ì¶©ëŒ ë°©í–¥ì— ë”°ë¼ ë°˜ì‚¬
                            if (Math.abs(crossWidth) > Math.abs(crossHeight)) {
                                // ìœ„/ì•„ë˜ ì¶©ëŒ
                                ball.dy = -ball.dy;
                            } else {
                                // ì¢Œ/ìš° ì¶©ëŒ
                                ball.dx = -ball.dx;
                            }
                            
                            // ë²½ëŒ íŒŒê´´
                            brick.status = 0;
                            bricksRemaining--;
                            score += brick.points;
                            
                            // íŒŒí‹°í´ íš¨ê³¼
                            createParticles(
                                brick.x + brick.width / 2,
                                brick.y + brick.height / 2,
                                brick.color,
                                12
                            );
                            
                            updateUI();
                            
                            // í•œ í”„ë ˆì„ì— í•˜ë‚˜ì˜ ë²½ëŒë§Œ ì²˜ë¦¬
                            return;
                        }
                    }
                }
            }
        }

        // ==================== ë ˆë²¨ ì™„ë£Œ ====================
        function levelComplete() {
            level++;
            gameStarted = false;
            
            // ë³´ë„ˆìŠ¤ ì ìˆ˜
            score += lives * 50;
            
            // ì˜¤ë²„ë ˆì´ í‘œì‹œ
            const overlay = document.getElementById('game-overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const overlaySubmessage = document.getElementById('overlay-submessage');
            
            overlayTitle.textContent = `ë ˆë²¨ ${level - 1} í´ë¦¬ì–´! ğŸ‰`;
            overlayMessage.textContent = `ì ìˆ˜: ${score}`;
            overlaySubmessage.textContent = 'ë‹¤ìŒ ë ˆë²¨ ì¤€ë¹„ ì¤‘...';
            overlay.classList.add('active');
            
            // ë‹¤ìŒ ë ˆë²¨ ì¤€ë¹„
            setTimeout(() => {
                createBricks();
                resetBall();
                ball.speed = GAME_CONFIG.BALL_INITIAL_SPEED + (level - 1) * 0.5;
                updateUI();
                
                overlay.classList.remove('active');
                
                // ìë™ ì‹œì‘
                setTimeout(() => {
                    if (sensorConnected && !gameOver) {
                        startGame();
                    }
                }, 500);
            }, 2000);
        }

        // ==================== ê²Œì„ ì¢…ë£Œ ====================
        function endGame(won) {
            gameStarted = false;
            gameOver = true;
            
            const overlay = document.getElementById('game-overlay');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayMessage = document.getElementById('overlay-message');
            const overlaySubmessage = document.getElementById('overlay-submessage');
            
            if (won) {
                overlayTitle.textContent = 'ğŸ† ê²Œì„ í´ë¦¬ì–´!';
                overlayMessage.textContent = `ìµœì¢… ì ìˆ˜: ${score}`;
                overlaySubmessage.textContent = 'ì¶•í•˜í•©ë‹ˆë‹¤!';
            } else {
                overlayTitle.textContent = 'ğŸ’¥ ê²Œì„ ì˜¤ë²„';
                overlayMessage.textContent = `ìµœì¢… ì ìˆ˜: ${score}`;
                overlaySubmessage.textContent = 'í”ë“¤ì–´ì„œ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”';
            }
            
            overlay.classList.add('active');
            
            console.log('ğŸ® ê²Œì„ ì¢…ë£Œ:', { won, score, level });
        }

        // ==================== ê²Œì„ ë¦¬ì…‹ ====================
        function resetGame() {
            gameStarted = false;
            gameOver = false;
            gamePaused = false;
            
            score = 0;
            lives = GAME_CONFIG.INITIAL_LIVES;
            level = 1;
            
            paddle.x = canvas.width / 2;
            paddle.targetX = paddle.x;
            
            resetBall();
            createBricks();
            updateUI();
            
            const overlay = document.getElementById('game-overlay');
            overlay.classList.remove('active');
            
            // ìë™ ì‹œì‘
            setTimeout(() => {
                if (sensorConnected && !gameOver) {
                    startGame();
                }
            }, 500);
            
            console.log('ğŸ”„ ê²Œì„ ë¦¬ì…‹');
        }

        // ==================== íŒŒí‹°í´ ìƒì„± ====================
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                const velocity = 2 + Math.random() * 3;
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * velocity,
                    vy: Math.sin(angle) * velocity,
                    color: color,
                    life: 1,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 3
                });
            }
        }

        // ==================== íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ====================
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // ==================== UI ì—…ë°ì´íŠ¸ ====================
        function updateUI() {
            document.getElementById('score-display').textContent = score;
            document.getElementById('lives-display').textContent = lives;
            document.getElementById('level-display').textContent = level;
            document.getElementById('bricks-display').textContent = bricksRemaining;
        }

        // ==================== ê²Œì„ ë Œë”ë§ ====================
        function renderGame() {
            // ë°°ê²½
            ctx.fillStyle = GAME_CONFIG.COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê²©ì íŒ¨í„´ (ë°°ê²½ ì¥ì‹)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 40) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // ë²½ëŒ ê·¸ë¦¬ê¸°
            drawBricks();

            // íŒ¨ë“¤ ê·¸ë¦¬ê¸°
            drawPaddle();

            // ê³µ ê·¸ë¦¬ê¸°
            drawBall();

            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            drawParticles();

            // ì„¼ì„œ ì—°ê²° ì•ˆë‚´ (ê²Œì„ ì‹œì‘ ì „)
            if (!gameStarted && !gameOver && sensorConnected) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('í”ë“¤ì–´ì„œ ì‹œì‘í•˜ì„¸ìš”!', canvas.width / 2, canvas.height / 2);
                
                ctx.font = '18px Arial';
                ctx.fillText('ë˜ëŠ” í™”ë©´ì„ í´ë¦­í•˜ì„¸ìš”', canvas.width / 2, canvas.height / 2 + 35);
            }

            // ê¸°ìš¸ê¸° ì¸ë””ì¼€ì´í„°
            if (sensorConnected && gameStarted) {
                drawTiltIndicator();
            }
        }

        // ==================== ë²½ëŒ ê·¸ë¦¬ê¸° ====================
        function drawBricks() {
            for (let row = 0; row < GAME_CONFIG.BRICK_ROWS; row++) {
                for (let col = 0; col < GAME_CONFIG.BRICK_COLS; col++) {
                    const brick = bricks[row][col];
                    
                    if (brick.status === 1) {
                        // ê·¸ë¼ë°ì´ì…˜ íš¨ê³¼
                        const gradient = ctx.createLinearGradient(
                            brick.x, brick.y,
                            brick.x, brick.y + brick.height
                        );
                        gradient.addColorStop(0, brick.color);
                        gradient.addColorStop(1, shadeColor(brick.color, -20));
                        
                        ctx.fillStyle = gradient;
                        
                        // ë‘¥ê·¼ ëª¨ì„œë¦¬ ì‚¬ê°í˜•
                        roundRect(ctx, brick.x, brick.y, brick.width, brick.height, 5);
                        ctx.fill();
                        
                        // í…Œë‘ë¦¬
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 2;
                        roundRect(ctx, brick.x, brick.y, brick.width, brick.height, 5);
                        ctx.stroke();
                        
                        // í•˜ì´ë¼ì´íŠ¸
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                        roundRect(ctx, brick.x + 5, brick.y + 5, brick.width - 10, brick.height / 3, 3);
                        ctx.fill();
                    }
                }
            }
        }

        // ==================== íŒ¨ë“¤ ê·¸ë¦¬ê¸° ====================
        function drawPaddle() {
            const x = paddle.x - paddle.width / 2;
            const y = paddle.y;
            
            // ê·¸ë¼ë°ì´ì…˜
            const gradient = ctx.createLinearGradient(x, y, x, y + paddle.height);
            gradient.addColorStop(0, GAME_CONFIG.COLORS.paddle);
            gradient.addColorStop(1, shadeColor(GAME_CONFIG.COLORS.paddle, -30));
            
            ctx.fillStyle = gradient;
            roundRect(ctx, x, y, paddle.width, paddle.height, 10);
            ctx.fill();
            
            // í…Œë‘ë¦¬
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            roundRect(ctx, x, y, paddle.width, paddle.height, 10);
            ctx.stroke();
            
            // í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            roundRect(ctx, x + 10, y + 5, paddle.width - 20, paddle.height / 3, 5);
            ctx.fill();
        }

        // ==================== ê³µ ê·¸ë¦¬ê¸° ====================
        function drawBall() {
            // ê·¸ë¼ë°ì´ì…˜
            const gradient = ctx.createRadialGradient(
                ball.x - ball.radius / 3, ball.y - ball.radius / 3, 0,
                ball.x, ball.y, ball.radius
            );
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, GAME_CONFIG.COLORS.ball);
            gradient.addColorStop(1, shadeColor(GAME_CONFIG.COLORS.ball, -30));
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // ì™¸ê³½ì„ 
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // ê¶¤ì  íš¨ê³¼ (ì´ë™ ì¤‘ì¼ ë•Œ)
            if (!ball.stuck && (ball.dx !== 0 || ball.dy !== 0)) {
                for (let i = 1; i <= 3; i++) {
                    const trailX = ball.x - ball.dx * i * 0.5;
                    const trailY = ball.y - ball.dy * i * 0.5;
                    const trailRadius = ball.radius * (1 - i * 0.2);
                    const trailAlpha = 0.3 - i * 0.1;
                    
                    ctx.fillStyle = `rgba(245, 87, 108, ${trailAlpha})`;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, trailRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ==================== íŒŒí‹°í´ ê·¸ë¦¬ê¸° ====================
        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        // ==================== ê¸°ìš¸ê¸° ì¸ë””ì¼€ì´í„° ====================
        function drawTiltIndicator() {
            const indicatorWidth = 200;
            const indicatorHeight = 20;
            const indicatorX = canvas.width / 2 - indicatorWidth / 2;
            const indicatorY = 20;
            
            // ë°°ê²½
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            roundRect(ctx, indicatorX, indicatorY, indicatorWidth, indicatorHeight, 10);
            ctx.fill();
            
            // ì¤‘ì•™ì„ 
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, indicatorY);
            ctx.lineTo(canvas.width / 2, indicatorY + indicatorHeight);
            ctx.stroke();
            
            // ê¸°ìš¸ê¸° í‘œì‹œ
            const tiltX = canvas.width / 2 + currentTilt * (indicatorWidth / 2);
            ctx.fillStyle = GAME_CONFIG.COLORS.paddle;
            ctx.beginPath();
            ctx.arc(tiltX, indicatorY + indicatorHeight / 2, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(tiltX, indicatorY + indicatorHeight / 2, 8, 0, Math.PI * 2);
            ctx.stroke();
        }

        // ==================== ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ====================
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function shadeColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }

        // ==================== ê²Œì„ ì‹œì‘ ====================
        window.addEventListener('load', () => {
            console.log('ğŸ® ì„¼ì„œ ë³¼ ê²Œì„ ë¡œë“œ ì™„ë£Œ');
            initGame();
        });

        // ==================== ì—ëŸ¬ ì²˜ë¦¬ ====================
        window.addEventListener('error', (event) => {
            console.error('âŒ ì—ëŸ¬ ë°œìƒ:', event.error);
        });

        // ==================== í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬ ====================
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>