
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ‚ ì•„ìŠ¬ì•„ìŠ¬ ì¼€ì´í¬ ë°°ë‹¬ë‹¨</title>
    <style>
        :root {
            --primary: #3b82f6; --secondary: #8b5cf6; --success: #10b981;
            --warning: #f59e0b; --error: #ef4444; --background: #0f172a;
            --surface: #1e293b; --text-primary: #f8fafc; --text-secondary: #cbd5e1;
        }
        body { 
            margin: 0; overflow: hidden; background-color: var(--background); 
            color: var(--text-primary); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex; justify-content: center; align-items: center; height: 100vh;
        }
        #gameContainer { width: 100%; height: 100%; position: relative; }
        #gameCanvas { display: block; }
        .ui-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            pointer-events: none; text-align: center;
        }
        .session-panel {
            position: absolute; top: 20px; left: 20px; background: rgba(30, 41, 59, 0.8);
            padding: 15px; border-radius: 12px; backdrop-filter: blur(5px);
            display: flex; flex-direction: column; align-items: center; gap: 10px; pointer-events: auto;
        }
        .session-title { font-size: 24px; font-weight: bold; color: var(--primary); }
        .session-code { font-size: 48px; font-weight: bold; letter-spacing: 4px; color: var(--warning); }
        .qr-container { width: 160px; height: 160px; background: white; border-radius: 8px; padding: 5px;}
        .qr-container img { width: 100%; height: 100%; }
        .connection-status { display: flex; gap: 10px; margin-top: 10px; }
        .player-status { padding: 8px 12px; border-radius: 8px; font-weight: bold; }
        .player-status.connected { background-color: var(--success); color: white; }
        .player-status.disconnected { background-color: var(--error); color: white; }
        .game-message {
            background: rgba(30, 41, 59, 0.9); padding: 20px 40px; border-radius: 15px;
            font-size: 3em; font-weight: bold; color: white; backdrop-filter: blur(10px);
            border: 2px solid var(--primary);
        }
        /* ê²Œì„ ì„¤ì • íŒ¨ë„ - ì™¼ìª½ í•˜ë‹¨ìœ¼ë¡œ ì´ë™ */
        .game-settings-panel {
            position: absolute; bottom: 20px; left: 20px; 
            background: rgba(30, 41, 59, 0.9); 
            padding: 15px; border-radius: 12px; backdrop-filter: blur(10px);
            display: flex; flex-direction: column; gap: 12px; pointer-events: auto;
            max-width: 280px; border: 1px solid rgba(59, 130, 246, 0.3);
        }
        
        .settings-section {
            display: flex; flex-direction: column; gap: 8px;
        }
        
        .settings-title {
            font-size: 14px; font-weight: bold; color: var(--primary);
            border-bottom: 1px solid rgba(59, 130, 246, 0.3);
            padding-bottom: 4px; margin-bottom: 4px;
        }

        /* ê²Œì„ ëª¨ë“œ ë²„íŠ¼ë“¤ì„ 2ì—´ë¡œ ë°°ì¹˜ */
        .mode-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 6px;
        }
        
        /* ì¼€ì´í¬ ë²„íŠ¼ë“¤ì„ 3ì—´ë¡œ ë°°ì¹˜ */
        .cake-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;
        }

        /* ìš°ì¸¡ í•˜ë‹¨ ì»¨íŠ¸ë¡¤ (ì¬ì‹œì‘, í—ˆë¸Œ, ë„ì›€ë§) */
        .main-controls {
            position: absolute; bottom: 20px; right: 20px; 
            display: flex; flex-direction: column; gap: 8px; pointer-events: auto;
        }
        
        /* ë„ì›€ë§ íŒ¨ë„ */
        .help-panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(15px);
            border-radius: 15px; padding: 25px; max-width: 600px; max-height: 80vh;
            border: 2px solid var(--primary); box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            color: white; font-size: 14px; line-height: 1.6; overflow-y: auto;
            display: none; z-index: 1000; pointer-events: auto;
        }
        
        .help-panel h3 {
            color: var(--primary); margin-top: 20px; margin-bottom: 10px;
        }
        
        .help-panel h3:first-child {
            margin-top: 0;
        }
        
        .help-close {
            position: absolute; top: 10px; right: 15px;
            background: none; border: none; color: var(--primary);
            font-size: 24px; cursor: pointer; padding: 5px;
        }
        
        .main-controls button, .main-controls a {
            padding: 10px 16px; background-color: var(--primary); color: white; border: none;
            border-radius: 8px; font-size: 14px; font-weight: bold; text-decoration: none; cursor: pointer;
            transition: all 0.2s; text-align: center; min-width: 100px;
        }
        .main-controls button:hover, .main-controls a:hover { 
            background-color: #2563eb; transform: translateY(-1px); 
        }

        /* ëª¨ë“œ ë²„íŠ¼ ìŠ¤íƒ€ì¼ ê°œì„  */
        .mode-btn {
            padding: 8px 12px; background-color: var(--surface); color: var(--text-secondary); 
            border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 6px; 
            font-size: 12px; cursor: pointer; transition: all 0.2s;
            position: relative; overflow: hidden; text-align: center;
            white-space: nowrap; min-height: 36px; display: flex; align-items: center; justify-content: center;
        }
        .mode-btn:hover { 
            background-color: var(--primary); color: white; 
            transform: translateY(-1px); box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4); 
        }
        .mode-btn.active { 
            background-color: var(--primary); color: white; font-weight: bold; 
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.6); border-color: var(--primary);
        }

        /* ì¼€ì´í¬ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
        .cake-btn {
            padding: 6px 8px; background-color: var(--surface); color: var(--text-secondary); 
            border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 5px; 
            font-size: 11px; cursor: pointer; transition: all 0.2s;
            text-align: center; min-height: 32px; display: flex; align-items: center; justify-content: center;
        }
        .cake-btn:hover { 
            background-color: var(--secondary); color: white; 
            transform: translateY(-1px); box-shadow: 0 2px 6px rgba(139, 92, 246, 0.4); 
        }
        .cake-btn.active { 
            background-color: var(--secondary); color: white; font-weight: bold; 
            box-shadow: 0 0 8px rgba(139, 92, 246, 0.6); border-color: var(--secondary);
        }
        .mode-btn:active { transform: translateY(0); }
        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        .mode-btn:hover::before {
            left: 100%;
        }
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
            animation: pulse 2s infinite;
        }
        .status-indicator.good { background-color: var(--success); }
        .status-indicator.warning { background-color: var(--warning); }
        .status-indicator.danger { background-color: var(--error); }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <audio id="bgm" src="./assets/bgm.mp3" loop></audio>
    <audio id="sfx-success" src="./assets/success.mp3"></audio>
    <audio id="sfx-fail" src="./assets/fail.mp3"></audio>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-overlay">
            <div id="messageBox" class="game-message">í”Œë ˆì´ì–´ ì—°ê²° ëŒ€ê¸°ì¤‘...</div>
            <div class="score-display" style="position: absolute; top: 20px; right: 20px; background: rgba(30, 41, 59, 0.8); padding: 15px; border-radius: 12px; backdrop-filter: blur(5px); pointer-events: auto; text-align: right;">
                <div style="font-size: 1.2em; font-weight: bold; color: var(--text-primary);">ë ˆë²¨: <span id="currentLevel">1</span> | ì ìˆ˜: <span id="currentScore">0</span></div>
                <div style="font-size: 1em; color: var(--text-secondary);">ìµœê³  ê¸°ë¡: <span id="highScore">0</span></div>
                <div style="font-size: 1em; color: var(--warning);" id="timerDisplay">ì‹œê°„: <span id="remainingTime">--</span></div>
                <div style="font-size: 1em; color: var(--success);" id="starsDisplay">â­ <span id="currentStars">0</span>/3</div>
                <div style="font-size: 0.9em; color: var(--text-secondary);" id="modeDisplay">ëª¨ë“œ: <span id="gameMode">ì¼ë°˜</span></div>
                <div style="font-size: 0.9em; color: var(--text-secondary); margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2);" id="cakeInfo">ğŸ‚ ì¼€ì´í¬ ì •ë³´</div>
            </div>
        </div>
        <div class="session-panel">
            <div class="session-title">ğŸ‚ ì¼€ì´í¬ ë°°ë‹¬ë‹¨</div>
            <div id="sessionCode" class="session-code">----</div>
            <div id="qrContainer" class="qr-container"></div>
            <div id="connectionStatus" class="connection-status">
                <!-- ì„¼ì„œ ìƒíƒœëŠ” JavaScriptì—ì„œ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>
        </div>
        <!-- ê²Œì„ ì„¤ì • íŒ¨ë„ (ì™¼ìª½ í•˜ë‹¨) -->
        <div class="game-settings-panel">
            <div class="settings-section">
                <div class="settings-title">ğŸ® ê²Œì„ ëª¨ë“œ</div>
                <div class="mode-grid">
                    <button id="normalMode" class="mode-btn active">ğŸ¯ ì¼ë°˜</button>
                    <button id="infiniteMode" class="mode-btn">â™¾ï¸ ë¬´í•œ</button>
                    <button id="timeAttackMode" class="mode-btn">â±ï¸ íƒ€ì„ì–´íƒ</button>
                    <button id="challengeMode" class="mode-btn">ğŸ”¥ ì±Œë¦°ì§€</button>
                    <button id="relayMode" class="mode-btn">ğŸƒ ë¦´ë ˆì´</button>
                    <button id="speedrunMode" class="mode-btn">âš¡ ìŠ¤í”¼ë“œëŸ°</button>
                </div>
                <button id="coop4Mode" class="mode-btn" style="grid-column: 1 / -1;">ğŸ‘¥ 4ì¸ í˜‘ë™ (ì„¼ì„œ4ê°œ)</button>
            </div>
            
            <div class="settings-section">
                <div class="settings-title">ğŸ‚ ì¼€ì´í¬ ì¢…ë¥˜</div>
                <div class="cake-grid">
                    <button id="basicCake" class="cake-btn" data-cake="basic">ğŸ‚ ê¸°ë³¸</button>
                    <button id="strawberryCake" class="cake-btn" data-cake="strawberry">ğŸ“ ë”¸ê¸°</button>
                    <button id="chocolateCake" class="cake-btn" data-cake="chocolate">ğŸ« ì´ˆì½œë¦¿</button>
                    <button id="weddingCake" class="cake-btn" data-cake="wedding">ğŸ‘° ì›¨ë”©</button>
                    <button id="iceCake" class="cake-btn" data-cake="ice">ğŸ¨ ì•„ì´ìŠ¤</button>
                    <button id="bombCake" class="cake-btn" data-cake="bomb">ğŸ’£ í­íƒ„</button>
                </div>
                <button id="randomCake" class="cake-btn active" data-cake="random" style="grid-column: 1 / -1; margin-top: 4px;">ğŸ² ëœë¤ ì„ íƒ</button>
            </div>
        </div>

        <!-- ë©”ì¸ ì»¨íŠ¸ë¡¤ (ì˜¤ë¥¸ìª½ í•˜ë‹¨) -->
        <div class="main-controls">
            <button id="resetButton" style="display: none;">ğŸ”„ ì¬ì‹œì‘</button>
            <button id="helpButton">â“ ë„ì›€ë§</button>
            <a href="/">ğŸ  í—ˆë¸Œë¡œ</a>
        </div>
        
        <!-- ë„ì›€ë§ íŒ¨ë„ -->
        <div class="help-panel" id="helpPanel">
            <button class="help-close" onclick="hideHelp()">Ã—</button>
            <h3>ğŸ® ê²Œì„ ë°©ë²•</h3>
            <p><strong>ëª©í‘œ:</strong> ì„¼ì„œë¥¼ ì´ìš©í•´ ì¼€ì´í¬ë¥¼ ì•ˆì „í•˜ê²Œ ëª©ì ì§€ê¹Œì§€ ë°°ë‹¬í•˜ì„¸ìš”!</p>
            <ul>
                <li>ğŸ¯ <strong>ì¼ë°˜ ëª¨ë“œ:</strong> ê¸°ë³¸ 2ì¸ í˜‘ë™ ë°°ë‹¬</li>
                <li>â™¾ï¸ <strong>ë¬´í•œ ëª¨ë“œ:</strong> ëì—†ëŠ” ë°°ë‹¬ ë„ì „</li>
                <li>â±ï¸ <strong>íƒ€ì„ ì–´íƒ:</strong> ì‹œê°„ ì œí•œ ë°°ë‹¬</li>
                <li>ğŸ”¥ <strong>ì±Œë¦°ì§€:</strong> ê·¹í•œ ë‚œì´ë„ ë°°ë‹¬</li>
                <li>ğŸƒ <strong>ë¦´ë ˆì´:</strong> 3êµ¬ê°„ ì—°ì† ë°°ë‹¬</li>
                <li>âš¡ <strong>ìŠ¤í”¼ë“œëŸ°:</strong> ì²´í¬í¬ì¸íŠ¸ ë¹ ë¥¸ í´ë¦¬ì–´</li>
                <li>ğŸ‘¥ <strong>4ì¸ í˜‘ë™:</strong> ëŒ€í˜• ì¼€ì´í¬ íŒ€ ë°°ë‹¬</li>
            </ul>
            
            <h3>ğŸ‚ ì¼€ì´í¬ ì¢…ë¥˜</h3>
            <ul>
                <li>ğŸŸ¢ <strong>ê¸°ë³¸ ì¼€ì´í¬ (ì‰¬ì›€):</strong> ê°€ì¥ ì•ˆì •ì ì´ê³  ë‹¤ë£¨ê¸° ì‰¬ì›€</li>
                <li>ğŸŸ¢ <strong>ë”¸ê¸° ì¼€ì´í¬ (ì‰¬ì›€):</strong> ê°€ë³ê³  ì•½ê°„ ë” ì•ˆì •ì </li>
                <li>ğŸŸ¡ <strong>ì´ˆì½œë¦¿ ì¼€ì´í¬ (ë³´í†µ):</strong> ë¬´ê±°ìš°ë©° ì˜¨ë„ì— ë¯¼ê°</li>
                <li>ğŸŸ¡ <strong>ì•„ì´ìŠ¤í¬ë¦¼ ì¼€ì´í¬ (ë³´í†µ):</strong> ì‹œê°„ì´ ì§€ë‚˜ë©´ ë…¹ìŒ</li>
                <li>ğŸ”´ <strong>ì›¨ë”© ì¼€ì´í¬ (ì–´ë ¤ì›€):</strong> ë§¤ìš° ë¶ˆì•ˆì •í•˜ì§€ë§Œ ê³ ë“ì </li>
                <li>ğŸ”´ <strong>í­íƒ„ ì¼€ì´í¬ (ì–´ë ¤ì›€):</strong> 30ì´ˆ íƒ€ì´ë¨¸, ë¹ ë¥¸ ë°°ë‹¬ í•„ìš”</li>
            </ul>
            
            <h3>ğŸŒ í™˜ê²½ íš¨ê³¼</h3>
            <ul>
                <li>ğŸŒ <strong>ì¼ë°˜ ë„ë¡œ:</strong> ê¸°ë³¸ í™˜ê²½</li>
                <li>ğŸŒ² <strong>ìˆ² ì† ê¸¸:</strong> ë‚˜ë¬´ ì¥ì• ë¬¼</li>
                <li>ğŸœï¸ <strong>ì‚¬ë§‰ ë„ë¡œ:</strong> ë†’ì€ ì˜¨ë„, ê°•í•œ ë°”ëŒ</li>
                <li>ğŸ–ï¸ <strong>í•´ë³€ ê¸¸:</strong> ëª¨ë˜ë°”ëŒ</li>
                <li>â„ï¸ <strong>ëˆˆ ë®ì¸ ê¸¸:</strong> ë‚®ì€ ì˜¨ë„, ë¯¸ë„ëŸ¬ì§</li>
                <li>ğŸŒ™ <strong>ì•¼ê°„ ë„ë¡œ:</strong> ì œí•œëœ ì‹œì•¼</li>
            </ul>
            
            <h3>ğŸ“± ì¡°ì‘ ë°©ë²•</h3>
            <ul>
                <li>ğŸ“² ëª¨ë°”ì¼ ì„¼ì„œ í´ë¼ì´ì–¸íŠ¸ì—ì„œ QRì½”ë“œ ìŠ¤ìº” ë˜ëŠ” 4ìë¦¬ ì½”ë“œ ì…ë ¥</li>
                <li>ğŸ“ <strong>ê¸°ìš¸ì´ê¸°:</strong> ì¼€ì´í¬ ì´ë™ ë°©í–¥ ì¡°ì ˆ</li>
                <li>ğŸ¤ <strong>í˜‘ë™:</strong> í”Œë ˆì´ì–´ ê°„ ê±°ë¦¬ ìœ ì§€ (7ë¯¸í„° ì´ë‚´)</li>
                <li>âš–ï¸ <strong>ê· í˜•:</strong> ì¼€ì´í¬ê°€ ë–¨ì–´ì§€ì§€ ì•Šë„ë¡ ì¡°ì‹¬</li>
                <li>ğŸ›£ï¸ <strong>ë„ë¡œ ìœ ì§€:</strong> ë„ë¡œ ë°–ìœ¼ë¡œ ì´íƒˆ ê¸ˆì§€</li>
            </ul>
            
            <h3>ğŸ’¡ íŒ</h3>
            <ul>
                <li>ğŸ¯ ì‰¬ìš´ ì¼€ì´í¬ë¶€í„° ì‹œì‘í•´ì„œ ì ì°¨ ì–´ë ¤ìš´ ì¼€ì´í¬ì— ë„ì „í•˜ì„¸ìš”</li>
                <li>ğŸ‘¥ íŒ€ì›ê³¼ ì†Œí†µí•˜ë©° ì›€ì§ì„ì„ ì¡°ìœ¨í•˜ì„¸ìš”</li>
                <li>ğŸŒ¡ï¸ í™˜ê²½ ì˜¨ë„ê°€ ì¼€ì´í¬ì— ì˜í–¥ì„ ì¤ë‹ˆë‹¤</li>
                <li>â­ ë³„ì ì€ ì‹œê°„, ì•ˆì •ì„±, ì¼€ì´í¬ ì¢…ë¥˜ì— ë”°ë¼ ê²°ì •ë©ë‹ˆë‹¤</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/js/SessionSDK.js"></script>

    <script>
        class CakeDeliveryGame {
            constructor() {
                this.sdk = new SessionSDK({
                    gameId: 'cake-delivery',
                    gameType: 'dual', // ê¸°ë³¸ê°’, ëª¨ë“œì— ë”°ë¼ ë³€ê²½ë¨
                    debug: false
                });

                this.gameState = 'waiting'; // waiting, ready, playing, success, fail, level_clear
                this.level = 1;
                this.maxLevel = 10; // í™•ì¥ëœ ë ˆë²¨
                this.gameMode = 'normal'; // normal, infinite, timeAttack, challenge, relay, speedrun, coop4
                this.players = {};
                this.cake = {};
                this.cakeType = 'basic'; // basic, strawberry, chocolate, wedding, ice, bomb
                
                // íƒ€ì´ë¨¸ ê´€ë¦¬ë¥¼ ìœ„í•œ ë°°ì—´
                this.activeTimeouts = [];
                this.activeIntervals = [];
                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬ë¥¼ ìœ„í•œ ì°¸ì¡° ì €ì¥
                this.boundEventListeners = {
                    resize: () => this.onWindowResize(),
                    beforeunload: () => this.cleanup()
                };
                
                // ì„¼ì„œ ë°ì´í„° ìŠ¤ë¬´ë”©ì„ ìœ„í•œ ì‹œìŠ¤í…œ
                this.sensorSmoothing = {
                    historySize: 3, // ìµœê·¼ 3ê°œ ê°’ì˜ í‰ê·  ì‚¬ìš© (ë°˜ì‘ì„± ê°œì„ )
                    deadZone: 1.5,  // 1.5ë„ ì´í•˜ì˜ ë¯¸ì„¸í•œ ì›€ì§ì„ ë¬´ì‹œ
                    smoothingFactor: 0.25, // ë¶€ë“œëŸ¬ìš´ ë³´ê°„ ê³„ìˆ˜ (ë°˜ì‘ì„±ê³¼ ë¶€ë“œëŸ¬ì›€ ê· í˜•)
                    playerHistory: {} // ê° í”Œë ˆì´ì–´ë³„ ì„¼ì„œ íˆìŠ¤í† ë¦¬
                };
                
                // ê²Œì„ ëª¨ë“œë³„ ë„ë¡œ í­ ì„¤ì •
                this.roadWidthConfig = {
                    normal: 15,      // ì¼ë°˜ ëª¨ë“œë“¤
                    coop4: 25        // 4ì¸ í˜‘ë™ ëª¨ë“œ (ëŒ€í˜• ì¼€ì´í¬ìš©)
                };
                // ë°¸ëŸ°ìŠ¤ ì¡°ì •ëœ ì¼€ì´í¬ ì„¤ì •
                this.cakeConfig = {
                    basic: { 
                        size: 1.5, weight: 1.0, stability: 1.0, color: 0xf472b6, layers: 1,
                        difficulty: 'easy', description: 'ê°€ì¥ ê¸°ë³¸ì ì¸ ì¼€ì´í¬. ì•ˆì •ì ì´ê³  ë‹¤ë£¨ê¸° ì‰¬ì›€'
                    },
                    strawberry: { 
                        size: 1.2, weight: 0.8, stability: 1.1, color: 0xff6b9d, layers: 1,
                        difficulty: 'easy', description: 'ê°€ë²¼ìš´ ë”¸ê¸° ì¼€ì´í¬. ì•½ê°„ ë” ì•ˆì •ì '
                    },
                    chocolate: { 
                        size: 1.8, weight: 1.3, stability: 0.8, color: 0x8b4513, layers: 2,
                        difficulty: 'medium', description: 'ë¬´ê±°ìš´ ì´ˆì½œë¦¿ ì¼€ì´í¬. ì˜¨ë„ì— ë¯¼ê°'
                    },
                    wedding: { 
                        size: 2.0, weight: 1.8, stability: 0.6, color: 0xfffff0, layers: 3,
                        difficulty: 'hard', description: 'ë‹¤ì¸µ ì›¨ë”© ì¼€ì´í¬. ë§¤ìš° ë¶ˆì•ˆì •í•˜ì§€ë§Œ ê³ ë“ì '
                    },
                    ice: { 
                        size: 1.4, weight: 0.9, stability: 0.9, color: 0x87ceeb, layers: 1, melting: true,
                        difficulty: 'medium', description: 'ì•„ì´ìŠ¤í¬ë¦¼ ì¼€ì´í¬. ì‹œê°„ ì œí•œ ìˆìŒ'
                    },
                    bomb: { 
                        size: 1.6, weight: 1.1, stability: 0.7, color: 0xff4500, layers: 1, timer: 35,
                        difficulty: 'hard', description: 'í­íƒ„ ì¼€ì´í¬. íƒ€ì´ë¨¸ ìˆì§€ë§Œ ë³´ìƒì´ í¼'
                    }
                };
                this.obstacles = [];
                this.destination = null;
                this.particles = [];
                this.cameraShake = { intensity: 0, decay: 0 };
                
                // í™•ì¥ëœ ì ìˆ˜ ì‹œìŠ¤í…œ
                this.currentScore = 0;
                this.highScore = parseInt(localStorage.getItem('cakeDeliveryHighScore') || '0');
                this.stars = 0; // 0-3 ë³„ì 
                this.deliveryTime = 0;
                this.perfectDeliveries = 0;
                this.totalDeliveries = 0;
                
                // íƒ€ì„ ì–´íƒ ëª¨ë“œ
                this.timeLimit = 60; // ì´ˆ
                this.remainingTime = this.timeLimit;
                this.isTimerActive = false;
                
                // ë¬´í•œ ëª¨ë“œ
                this.infiniteLevel = 1;
                this.consecutiveDeliveries = 0;
                
                // ë¦´ë ˆì´ ëª¨ë“œ
                this.relaySegments = 3; // êµ¬ê°„ ìˆ˜
                this.currentSegment = 1;
                this.segmentTargets = []; // ê° êµ¬ê°„ì˜ ëª©ì ì§€
                
                // ìŠ¤í”¼ë“œëŸ° ëª¨ë“œ
                this.speedrunTime = 0;
                this.speedrunBestTime = parseFloat(localStorage.getItem('speedrunBest') || '999');
                this.speedrunCheckpoints = [];
                
                // 4ì¸ í˜‘ë™ ëª¨ë“œ
                this.coop4Players = {};
                this.bigCakeSize = 2.0; // ë” í° ì¼€ì´í¬
                this.coop4Formation = 'square'; // square, diamond, line
                
                // ì¼€ì´í¬ ë¬¼ë¦¬ ë° ìƒíƒœ ì´ˆê¸°í™”
                this.initializeCakePhysicsVariables();
                
                // í™˜ê²½ ì‹œìŠ¤í…œ
                this.environmentConfig = {
                    normal: { 
                        skyColor: 0x87ceeb, 
                        floorColor: 0x4a5568, 
                        ambientLight: 0.6, 
                        directionalLight: 0.8,
                        fogNear: 50, 
                        fogFar: 200,
                        name: 'ì¼ë°˜ ë„ë¡œ'
                    },
                    forest: { 
                        skyColor: 0x228b22, 
                        floorColor: 0x8b4513, 
                        ambientLight: 0.4, 
                        directionalLight: 0.6,
                        fogNear: 30, 
                        fogFar: 100,
                        name: 'ìˆ² ì† ê¸¸'
                    },
                    desert: { 
                        skyColor: 0xffd700, 
                        floorColor: 0xf4a460, 
                        ambientLight: 0.8, 
                        directionalLight: 1.0,
                        fogNear: 80, 
                        fogFar: 300,
                        name: 'ì‚¬ë§‰ ë„ë¡œ'
                    },
                    beach: { 
                        skyColor: 0x00bfff, 
                        floorColor: 0xffefd5, 
                        ambientLight: 0.7, 
                        directionalLight: 0.9,
                        fogNear: 60, 
                        fogFar: 250,
                        name: 'í•´ë³€ ê¸¸'
                    },
                    winter: { 
                        skyColor: 0xb0c4de, 
                        floorColor: 0xffffff, 
                        ambientLight: 0.5, 
                        directionalLight: 0.7,
                        fogNear: 40, 
                        fogFar: 150,
                        name: 'ëˆˆ ë®ì¸ ê¸¸'
                    },
                    night: { 
                        skyColor: 0x191970, 
                        floorColor: 0x2f2f2f, 
                        ambientLight: 0.2, 
                        directionalLight: 0.4,
                        fogNear: 20, 
                        fogFar: 80,
                        name: 'ì•¼ê°„ ë„ë¡œ'
                    }
                };
                
                this.currentEnvironment = 'normal';
                
                // ì• ë‹ˆë©”ì´ì…˜ ì‹œìŠ¤í…œ
                this.clock = new THREE.Clock();

                // í™•ì¥ëœ ë ˆë²¨ ì„¤ì •
                this.levelConfig = {
                    1: { forwardSpeed: 0.08, obstacles: 2, holes: 1, movingObstacles: 0, wind: 0, timeLimit: 45, theme: 'normal' },
                    2: { forwardSpeed: 0.10, obstacles: 3, holes: 1, movingObstacles: 1, wind: 0.1, timeLimit: 40, theme: 'normal' },
                    3: { forwardSpeed: 0.12, obstacles: 4, holes: 2, movingObstacles: 1, wind: 0.15, timeLimit: 38, theme: 'city' },
                    4: { forwardSpeed: 0.14, obstacles: 5, holes: 2, movingObstacles: 2, wind: 0.2, timeLimit: 35, theme: 'city' },
                    5: { forwardSpeed: 0.16, obstacles: 6, holes: 3, movingObstacles: 2, wind: 0.25, timeLimit: 33, theme: 'forest' },
                    6: { forwardSpeed: 0.18, obstacles: 7, holes: 3, movingObstacles: 3, wind: 0.3, timeLimit: 30, theme: 'forest' },
                    7: { forwardSpeed: 0.20, obstacles: 8, holes: 4, movingObstacles: 3, wind: 0.35, timeLimit: 28, theme: 'mountain' },
                    8: { forwardSpeed: 0.22, obstacles: 9, holes: 4, movingObstacles: 4, wind: 0.4, timeLimit: 25, theme: 'beach' },
                    9: { forwardSpeed: 0.24, obstacles: 10, holes: 5, movingObstacles: 4, wind: 0.45, timeLimit: 23, theme: 'winter' },
                    10: { forwardSpeed: 0.26, obstacles: 12, holes: 6, movingObstacles: 5, wind: 0.5, timeLimit: 20, theme: 'night' }
                };
                
                // ê²Œì„ ëª¨ë“œë³„ ì„¤ì •
                this.modeConfig = {
                    normal: { lives: 3, scoreMult: 1.0, description: 'ì¼ë°˜ ëª¨ë“œ', players: 2 },
                    infinite: { lives: 1, scoreMult: 1.5, description: 'ë¬´í•œ ë„ì „ ëª¨ë“œ', players: 2 },
                    timeAttack: { lives: 1, scoreMult: 2.0, description: 'ì‹œê°„ ì œí•œ ëª¨ë“œ', players: 2 },
                    challenge: { lives: 1, scoreMult: 3.0, description: 'ê·¹í•œ ì±Œë¦°ì§€', players: 2 },
                    relay: { lives: 2, scoreMult: 1.8, description: 'ë¦´ë ˆì´ ë°°ë‹¬', players: 2 },
                    speedrun: { lives: 1, scoreMult: 2.5, description: 'ìŠ¤í”¼ë“œëŸ°', players: 2 },
                    coop4: { lives: 1, scoreMult: 4.0, description: '4ì¸ í˜‘ë™ (ì„¼ì„œ4ê°œ)', players: 4 }
                };

                this.initUI();
                this.init3D();
                this.initAudio();
                this.setupEvents();
                
                this.animate = this.animate.bind(this);
                this.animate();
            }
            
            // ì¼€ì´í¬ ë¬¼ë¦¬ ë³€ìˆ˜ ì´ˆê¸°í™”
            initializeCakePhysicsVariables() {
                this.cakePhysics = {
                    instability: 0,
                    meltingTimer: 0,
                    bombTimer: 0,
                    temperature: 20,
                    velocity: new THREE.Vector3(0, 0, 0),
                    angularVelocity: new THREE.Vector3(0, 0, 0),
                    elasticity: 0.5,
                    viscosity: 0.1,
                    volume: 1.0,
                    density: 1.0
                };
                
                this.environmentForces = {
                    wind: new THREE.Vector3(0, 0, 0),
                    gravity: new THREE.Vector3(0, -9.81, 0)
                };
            }

            initUI() {
                this.messageBox = document.getElementById('messageBox');
                this.resetButton = document.getElementById('resetButton');
                this.resetButton.onclick = () => this.resetGame();
                
                // ê¸°ì¡´ UI ìš”ì†Œë“¤
                this.currentScoreDisplay = document.getElementById('currentScore');
                this.highScoreDisplay = document.getElementById('highScore');
                
                // í™•ì¥ëœ UI ìš”ì†Œë“¤
                this.currentLevelDisplay = document.getElementById('currentLevel');
                this.remainingTimeDisplay = document.getElementById('remainingTime');
                this.currentStarsDisplay = document.getElementById('currentStars');
                this.gameModeDisplay = document.getElementById('gameMode');
                this.timerDisplay = document.getElementById('timerDisplay');
                this.starsDisplay = document.getElementById('starsDisplay');
                
                // ê²Œì„ ëª¨ë“œ ë²„íŠ¼ë“¤
                this.normalModeBtn = document.getElementById('normalMode');
                this.infiniteModeBtn = document.getElementById('infiniteMode');
                this.timeAttackModeBtn = document.getElementById('timeAttackMode');
                this.challengeModeBtn = document.getElementById('challengeMode');
                this.relayModeBtn = document.getElementById('relayMode');
                this.speedrunModeBtn = document.getElementById('speedrunMode');
                this.coop4ModeBtn = document.getElementById('coop4Mode');
                
                // ëª¨ë“œ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
                this.normalModeBtn.onclick = () => this.selectGameMode('normal');
                this.infiniteModeBtn.onclick = () => this.selectGameMode('infinite');
                this.timeAttackModeBtn.onclick = () => this.selectGameMode('timeAttack');
                
                // ì¼€ì´í¬ ì„ íƒ ë²„íŠ¼ë“¤
                this.selectedCakeType = 'random'; // ê¸°ë³¸ê°’ì€ ëœë¤
                const cakeButtons = document.querySelectorAll('.cake-btn');
                cakeButtons.forEach(button => {
                    button.onclick = () => this.selectCakeType(button.dataset.cake);
                });
                this.challengeModeBtn.onclick = () => this.selectGameMode('challenge');
                this.relayModeBtn.onclick = () => this.selectGameMode('relay');
                this.speedrunModeBtn.onclick = () => this.selectGameMode('speedrun');
                this.coop4ModeBtn.onclick = () => this.selectGameMode('coop4');
                
                // ê¸°ë³¸ ëª¨ë“œ(ì¼ë°˜ ëª¨ë“œ)ë¡œ ì„¼ì„œ HUD ì´ˆê¸°í™”
                this.createSensorStatusHUD(2);
                
                this.updateScoreDisplay();
            }

            // ê²Œì„ ëª¨ë“œ ì„ íƒ
            selectGameMode(mode) {
                if (this.gameState === 'playing') return; // ê²Œì„ ì¤‘ì—ëŠ” ëª¨ë“œ ë³€ê²½ ë¶ˆê°€
                
                this.gameMode = mode;
                
                // ëª¨ë“œë³„ ê²Œì„ íƒ€ì… ë³€ê²½
                const requiredGameType = this.getRequiredGameType(mode);
                if (this.sdk.gameType !== requiredGameType) {
                    this.changeGameType(requiredGameType);
                }
                
                // ëª¨ë“œë³„ ì´ˆê¸° ì„¤ì •
                switch(mode) {
                    case 'infinite':
                        this.infiniteLevel = 1;
                        this.consecutiveDeliveries = 0;
                        break;
                    case 'timeAttack':
                        this.remainingTime = this.timeLimit;
                        this.isTimerActive = false; // ê²Œì„ ì‹œì‘ ì „ê¹Œì§€ ë¹„í™œì„±í™”
                        break;
                    case 'challenge':
                        this.level = 5; // ì±Œë¦°ì§€ëŠ” ì¤‘ê°„ ë ˆë²¨ë¶€í„° ì‹œì‘
                        break;
                    case 'relay':
                        this.currentSegment = 1;
                        this.setupRelayTargets();
                        break;
                    case 'speedrun':
                        this.speedrunTime = 0;
                        this.setupSpeedrunCheckpoints();
                        break;
                    case 'coop4':
                        this.bigCakeSize = 2.0;
                        this.showStatusMessage('4ì¸ í˜‘ë™ ëª¨ë“œ: ì„¼ì„œ 4ê°œê°€ í•„ìš”í•©ë‹ˆë‹¤!', 4000);
                        break;
                    default:
                        this.level = 1;
                }
                
                // ëª¨ë“œì— ë”°ë¥¸ ì„¼ì„œ HUD ìƒì„±
                const requiredPlayers = this.modeConfig[mode].players;
                this.createSensorStatusHUD(requiredPlayers);
                
                // ëª¨ë“œì— ë”°ë¥¸ ë„ë¡œ í­ ì—…ë°ì´íŠ¸
                this.updateRoadWidth(mode);
                
                this.updateModeButtons();
                this.updateUI();
                
                console.log(`ğŸ® ê²Œì„ ëª¨ë“œ ë³€ê²½: ${this.modeConfig[mode].description} (ê²Œì„íƒ€ì…: ${requiredGameType}, í”Œë ˆì´ì–´: ${requiredPlayers}ëª…)`);
            }
            
            getRequiredGameType(mode) {
                switch(mode) {
                    case 'coop4':
                        return 'multi'; // 4ëª… ì´ìƒ ì§€ì›
                    default:
                        return 'dual'; // 2ëª… ê¸°ë³¸
                }
            }
            
            changeGameType(newGameType) {
                try {
                    // ê¸°ì¡´ ì„¸ì…˜ì´ ìˆë‹¤ë©´ ì •ë¦¬
                    if (this.sdk.sessionCode) {
                        this.showStatusMessage('ê²Œì„ íƒ€ì…ì„ ë³€ê²½í•˜ëŠ” ì¤‘...', 2000);
                    }
                    
                    // ìƒˆë¡œìš´ SDK ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
                    this.sdk = new SessionSDK({
                        gameId: 'cake-delivery',
                        gameType: newGameType,
                        debug: false
                    });
                    
                    // ì´ë²¤íŠ¸ ì¬ì„¤ì •
                    this.setupEvents();
                    
                    console.log(`ê²Œì„ íƒ€ì… ë³€ê²½: ${newGameType}`);
                    
                } catch (error) {
                    console.error('ê²Œì„ íƒ€ì… ë³€ê²½ ì˜¤ë¥˜:', error);
                    this.showErrorMessage('ê²Œì„ íƒ€ì… ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            }

            // ëª¨ë“œ ë²„íŠ¼ ì—…ë°ì´íŠ¸
            updateModeButtons() {
                [this.normalModeBtn, this.infiniteModeBtn, this.timeAttackModeBtn, this.challengeModeBtn, 
                 this.relayModeBtn, this.speedrunModeBtn, this.coop4ModeBtn].forEach(btn => {
                    btn.classList.remove('active');
                });
                
                switch(this.gameMode) {
                    case 'normal': this.normalModeBtn.classList.add('active'); break;
                    case 'infinite': this.infiniteModeBtn.classList.add('active'); break;
                    case 'timeAttack': this.timeAttackModeBtn.classList.add('active'); break;
                    case 'challenge': this.challengeModeBtn.classList.add('active'); break;
                    case 'relay': this.relayModeBtn.classList.add('active'); break;
                    case 'speedrun': this.speedrunModeBtn.classList.add('active'); break;
                    case 'coop4': this.coop4ModeBtn.classList.add('active'); break;
                }
            }
            
            selectCakeType(cakeType) {
                try {
                    // ìœ íš¨í•œ ì¼€ì´í¬ íƒ€ì…ì¸ì§€ í™•ì¸
                    const validTypes = [...Object.keys(this.cakeConfig), 'random'];
                    if (!validTypes.includes(cakeType)) {
                        console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì¼€ì´í¬ íƒ€ì…: ${cakeType}`);
                        return;
                    }
                    
                    this.selectedCakeType = cakeType;
                    
                    // ì¼€ì´í¬ ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
                    const cakeButtons = document.querySelectorAll('.cake-btn');
                    cakeButtons.forEach(button => {
                        button.classList.remove('active');
                    });
                    
                    const selectedButton = document.querySelector(`[data-cake="${cakeType}"]`);
                    if (selectedButton) {
                        selectedButton.classList.add('active');
                        
                        // ë²„íŠ¼ í´ë¦­ í”¼ë“œë°±
                        selectedButton.style.transform = 'scale(0.95)';
                        this.safeSetTimeout(() => {
                            selectedButton.style.transform = '';
                        }, 100);
                    }
                    
                    console.log(`ğŸ‚ ì¼€ì´í¬ íƒ€ì… ì„ íƒ: ${cakeType}`);
                    
                    // ì¼€ì´í¬ ì •ë³´ ë¯¸ë¦¬ë³´ê¸° í‘œì‹œ
                    this.showCakePreview(cakeType);
                    
                    // ê²Œì„ ì¤‘ì´ ì•„ë‹ ë•ŒëŠ” ì¦‰ì‹œ ì¼€ì´í¬ ì—…ë°ì´íŠ¸
                    if (this.gameState === 'waiting' || this.gameState === 'ready') {
                        this.updateCakeInGame(cakeType);
                    }
                    
                } catch (error) {
                    console.error('ì¼€ì´í¬ ì„ íƒ ì˜¤ë¥˜:', error);
                    this.showErrorMessage('ì¼€ì´í¬ ì„ íƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            }
            
            showCakePreview(cakeType) {
                if (cakeType === 'random') return;
                
                const config = this.cakeConfig[cakeType];
                if (!config) return;
                
                const cakeNames = {
                    basic: 'ê¸°ë³¸ ì¼€ì´í¬',
                    strawberry: 'ë”¸ê¸° ì¼€ì´í¬',
                    chocolate: 'ì´ˆì½œë¦¿ ì¼€ì´í¬', 
                    wedding: 'ì›¨ë”© ì¼€ì´í¬',
                    ice: 'ì•„ì´ìŠ¤í¬ë¦¼ ì¼€ì´í¬',
                    bomb: 'í­íƒ„ ì¼€ì´í¬'
                };
                
                const difficultyColor = this.getDifficultyColor(config.difficulty);
                const previewText = `ğŸ‚ ${cakeNames[cakeType]} - ë‚œì´ë„: ${config.difficulty} | ${config.description}`;
                this.showStatusMessage(previewText, 3000);
            }
            
            updateCakeInGame(cakeType) {
                try {
                    if (cakeType === 'random') {
                        // ëœë¤ ì¼€ì´í¬ ì„ íƒ
                        const cakeTypes = Object.keys(this.cakeConfig);
                        cakeType = cakeTypes[Math.floor(Math.random() * cakeTypes.length)];
                    }
                    
                    this.cakeType = cakeType;
                    
                    // ê²Œì„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ë‹¤ë©´ ì¼€ì´í¬ ë‹¤ì‹œ ìƒì„±
                    if (this.cake.mesh && this.scene) {
                        this.scene.remove(this.cake.mesh);
                        this.cake.mesh = null;
                        this.createCake();
                        console.log(`ğŸ‚ ì¼€ì´í¬ê°€ ${cakeType}(ìœ¼)ë¡œ ì¦‰ì‹œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                    }
                    
                } catch (error) {
                    console.error('ì¼€ì´í¬ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
                    this.showErrorMessage('ì¼€ì´í¬ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                }
            }
            
            showStatusMessage(message, duration = 3000) {
                const messageElement = document.getElementById('messageBox');
                if (!messageElement) {
                    console.warn('âš ï¸ messageBox ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                    return;
                }
                
                // ì•ˆì „í•œ ë©”ì‹œì§€ ì„¤ì • (XSS ë°©ì§€)
                if (typeof message !== 'string') {
                    message = String(message);
                }
                messageElement.textContent = message;
                messageElement.style.display = 'flex';
                messageElement.style.opacity = '0.8';
                
                // ì´ì „ íƒ€ì´ë¨¸ê°€ ìˆë‹¤ë©´ ì •ë¦¬
                if (this.statusMessageTimer) {
                    clearTimeout(this.statusMessageTimer);
                }
                
                this.statusMessageTimer = this.safeSetTimeout(() => {
                    messageElement.style.opacity = '0';
                    this.safeSetTimeout(() => {
                        messageElement.style.display = 'none';
                        this.statusMessageTimer = null;
                    }, 300);
                }, duration);
            }
            
            showErrorMessage(message) {
                console.error(message);
                this.showStatusMessage(`âŒ ${message}`, 4000);
            }
            
            getDifficultyColor(difficulty) {
                switch(difficulty) {
                    case 'easy': return 'var(--success)';
                    case 'medium': return 'var(--warning)';
                    case 'hard': return 'var(--error)';
                    default: return 'var(--text-secondary)';
                }
            }
            
            // ì¼€ì´í¬ íƒ€ì…ë³„ ì ìˆ˜ ë°°ìœ¨ ê³„ì‚°
            getCakeScoreMultiplier(cakeType) {
                const config = this.cakeConfig[cakeType];
                if (!config) return 1.0;
                
                const difficultyMultipliers = {
                    'easy': 1.0,
                    'medium': 1.5,
                    'hard': 2.0
                };
                
                // ê¸°ë³¸ ë°°ìœ¨ + ë‚œì´ë„ ë°°ìœ¨ + ì•ˆì •ì„± ì—­ë°°ìœ¨
                const baseMultiplier = difficultyMultipliers[config.difficulty] || 1.0;
                const stabilityMultiplier = 1 + (1 - config.stability) * 0.5;
                
                return baseMultiplier * stabilityMultiplier;
            }
            
            // ê°œì„ ëœ ì ìˆ˜ ê³„ì‚° ì‹œìŠ¤í…œ
            calculateFinalScore(deliveryTime, cakeType, levelMultiplier = 1.0) {
                const baseScore = 1000;
                const timeBonus = Math.max(0, 100 - deliveryTime) * 10;
                const cakeMultiplier = this.getCakeScoreMultiplier(cakeType);
                
                // ì™„ë²½í•œ ë°°ë‹¬ ë³´ë„ˆìŠ¤ (ì¼€ì´í¬ ìƒíƒœ ê¸°ë°˜)
                const perfectBonus = this.cakePhysics && this.cakePhysics.instability < 0.3 ? 500 : 0;
                
                const finalScore = Math.floor(
                    (baseScore + timeBonus + perfectBonus) * cakeMultiplier * levelMultiplier
                );
                
                return {
                    total: finalScore,
                    breakdown: {
                        base: baseScore,
                        time: timeBonus,
                        perfect: perfectBonus,
                        cakeMultiplier: cakeMultiplier,
                        levelMultiplier: levelMultiplier
                    }
                };
            }

            // ë³„ì  ê³„ì‚° (ì„±ê³¼ ê¸°ë°˜)
            calculateStars(deliveryTime, instability, collisions = 0) {
                let stars = 3; // ê¸°ë³¸ 3ì  ë§Œì 
                
                // ë°°ë‹¬ ì‹œê°„ ê¸°ì¤€ ê°ì 
                if (deliveryTime > 60) stars -= 1;
                else if (deliveryTime > 30) stars -= 0.5;
                
                // ì¼€ì´í¬ ë¶ˆì•ˆì •ë„ ê¸°ì¤€ ê°ì 
                if (instability > 0.7) stars -= 1;
                else if (instability > 0.4) stars -= 0.5;
                
                // ì¶©ëŒ íšŸìˆ˜ ê¸°ì¤€ ê°ì 
                stars -= Math.min(collisions * 0.5, 2);
                
                return Math.max(0, Math.floor(stars));
            }
            
            // 4ì¸ í˜‘ë™ íŒ€ì›Œí¬ ë³´ë„ˆìŠ¤ ê³„ì‚°
            calculateTeamworkBonus() {
                if (this.gameMode !== 'coop4' || Object.keys(this.players).length !== 4) {
                    return 0;
                }
                
                const sortedPlayerIds = Object.keys(this.players).sort();
                const playerPositions = sortedPlayerIds.map(id => this.players[id].mesh.position);
                const centerPos = new THREE.Vector3(
                    playerPositions.reduce((sum, pos) => sum + pos.x, 0) / 4,
                    0,
                    playerPositions.reduce((sum, pos) => sum + pos.z, 0) / 4
                );
                
                // íŒ€ ê²°ì†ë„ ì¸¡ì • (í”Œë ˆì´ì–´ë“¤ì´ ì–¼ë§ˆë‚˜ ë­‰ì³ìˆëŠ”ì§€)
                const distances = playerPositions.map(pos => pos.distanceTo(centerPos));
                const avgDistance = distances.reduce((sum, dist) => sum + dist, 0) / 4;
                const maxDistance = Math.max(...distances);
                
                // íŒ€ì›Œí¬ ì ìˆ˜ ê³„ì‚° (ê±°ë¦¬ê°€ ê°€ê¹Œìš¸ìˆ˜ë¡ ë†’ì€ ì ìˆ˜)
                let teamworkScore = 1000; // ê¸°ë³¸ íŒ€ì›Œí¬ ë³´ë„ˆìŠ¤
                
                // í‰ê·  ê±°ë¦¬ ê¸°ì¤€ ë³´ë„ˆìŠ¤
                if (avgDistance < 2.0) teamworkScore += 500; // ì™„ë²½í•œ íŒ€ì›Œí¬
                else if (avgDistance < 4.0) teamworkScore += 300; // ì¢‹ì€ íŒ€ì›Œí¬
                else if (avgDistance < 6.0) teamworkScore += 100; // ë³´í†µ íŒ€ì›Œí¬
                
                // ìµœëŒ€ ê±°ë¦¬ í˜ë„í‹°
                if (maxDistance > 8.0) teamworkScore -= 300; // ëˆ„êµ°ê°€ ë„ˆë¬´ ë©€ë¦¬
                
                console.log(`ğŸ‘¥ íŒ€ì›Œí¬ ë³´ë„ˆìŠ¤: í‰ê· ê±°ë¦¬ ${avgDistance.toFixed(2)}, ìµœëŒ€ê±°ë¦¬ ${maxDistance.toFixed(2)}, ë³´ë„ˆìŠ¤ ${teamworkScore}`);
                return Math.max(0, teamworkScore);
            }

            // UI ì—…ë°ì´íŠ¸
            updateUI() {
                if (this.currentLevelDisplay) {
                    this.currentLevelDisplay.textContent = this.gameMode === 'infinite' ? this.infiniteLevel : this.level;
                }
                if (this.gameModeDisplay) {
                    this.gameModeDisplay.textContent = this.modeConfig[this.gameMode].description;
                }
                if (this.currentStarsDisplay) {
                    this.currentStarsDisplay.textContent = this.stars || 0;
                }
                
                // íƒ€ì„ ì–´íƒ ëª¨ë“œì—ì„œë§Œ íƒ€ì´ë¨¸ í‘œì‹œ
                if (this.timerDisplay) {
                    this.timerDisplay.style.display = (this.gameMode === 'timeAttack' || this.gameMode === 'speedrun') ? 'block' : 'none';
                }
                if (this.remainingTimeDisplay) {
                    if (this.gameMode === 'timeAttack') {
                        this.remainingTimeDisplay.textContent = Math.ceil(this.remainingTime);
                        // ì´ˆê¸° ìƒ‰ìƒ ì„¤ì •
                        if (this.remainingTime > 30) {
                            this.remainingTimeDisplay.style.color = '#f8fafc'; // ê¸°ë³¸ í°ìƒ‰
                        }
                    } else if (this.gameMode === 'speedrun') {
                        this.remainingTimeDisplay.textContent = this.speedrunTime.toFixed(1);
                    }
                }
                
                this.updateScoreDisplay();
            }

            // ë¦´ë ˆì´ ëª¨ë“œ ëª©í‘œ ì„¤ì •
            setupRelayTargets() {
                this.segmentTargets = [];
                const segmentLength = 30; // ê° êµ¬ê°„ì˜ ê¸¸ì´
                
                for (let i = 0; i < this.relaySegments; i++) {
                    this.segmentTargets.push({
                        position: new THREE.Vector3(0, 0, -(i + 1) * segmentLength),
                        reached: false,
                        theme: ['normal', 'city', 'forest'][i] || 'normal'
                    });
                }
                
                console.log(`ğŸƒ ë¦´ë ˆì´ êµ¬ê°„ ì„¤ì •: ${this.relaySegments}ê°œ êµ¬ê°„`);
            }

            // ìŠ¤í”¼ë“œëŸ° ì²´í¬í¬ì¸íŠ¸ ì„¤ì •
            setupSpeedrunCheckpoints() {
                this.speedrunCheckpoints = [];
                const checkpointDistance = 20;
                
                for (let i = 1; i <= 5; i++) {
                    this.speedrunCheckpoints.push({
                        position: new THREE.Vector3(0, 0, -i * checkpointDistance),
                        reached: false,
                        targetTime: i * 15 // ê° ì²´í¬í¬ì¸íŠ¸ê¹Œì§€ì˜ ëª©í‘œ ì‹œê°„ (ì´ˆ)
                    });
                }
                
                console.log(`âš¡ ìŠ¤í”¼ë“œëŸ° ì²´í¬í¬ì¸íŠ¸ ì„¤ì •: ${this.speedrunCheckpoints.length}ê°œ`);
            }

            // 4ì¸ í˜‘ë™ í”Œë ˆì´ì–´ ë°°ì¹˜
            setup4PlayerPositions() {
                const positions = {
                    square: [
                        { x: -2, z: -2 }, { x: 2, z: -2 },
                        { x: -2, z: 2 }, { x: 2, z: 2 }
                    ],
                    diamond: [
                        { x: 0, z: -3 }, { x: -2, z: 0 },
                        { x: 2, z: 0 }, { x: 0, z: 3 }
                    ],
                    line: [
                        { x: -3, z: 0 }, { x: -1, z: 0 },
                        { x: 1, z: 0 }, { x: 3, z: 0 }
                    ]
                };
                
                return positions[this.coop4Formation] || positions.square;
            }

            init3D() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 15, 10);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;

                // ì¡°ëª…
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 5);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                this.scene.add(directionalLight);

                // ë³„ ë°°ê²½ ì¶”ê°€
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.5 });
                const starVertices = [];
                for (let i = 0; i < 10000; i++) {
                    const x = (Math.random() - 0.5) * 2000;
                    const y = (Math.random() - 0.5) * 2000;
                    const z = (Math.random() - 0.5) * 2000;
                    starVertices.push(x, y, z);
                }
                starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
                this.starField = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(this.starField);

                // ì´ˆê¸° ë„ë¡œ í­ì€ ì¼ë°˜ ëª¨ë“œ ê¸°ì¤€ (ë‚˜ì¤‘ì— ëª¨ë“œì— ë”°ë¼ ë³€ê²½ë¨)
                this.roadWidth = this.roadWidthConfig.normal;
                const floorGeometry = new THREE.PlaneGeometry(this.roadWidth, 100);
                const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -0.5;
                floor.position.z = -50; // ë„ë¡œ ì‹œì‘ ìœ„ì¹˜ ì¡°ì •
                floor.receiveShadow = true;
                floor.name = 'gameFloor'; // ë‚˜ì¤‘ì— ì°¾ê¸° ìœ„í•œ ì´ë¦„
                this.scene.add(floor);
            }

            setupEvents() {
                this.sdk.on('connected', () => this.sdk.createSession());

                this.sdk.on('session-created', (event) => {
                    const session = event.detail || event;
                    this.displaySessionInfo(session);
                });

                this.sdk.on('sensor-connected', (event) => {
                    const data = event.detail || event;
                    this.addPlayer(data.sensorId);
                    this.updatePlayerStatus();
                });

                this.sdk.on('sensor-disconnected', (event) => {
                    const data = event.detail || event;
                    this.removePlayer(data.sensorId);
                    this.updatePlayerStatus();
                });

                this.sdk.on('game-ready', () => {
                    this.gameState = 'ready';
                    this.messageBox.textContent = '3ì´ˆ í›„ ì‹œì‘!';
                    this.safeSetTimeout(() => {
                        this.sdk.startGame();
                        this.gameState = 'playing';
                        this.messageBox.style.display = 'none';
                    }, 3000);
                });

                this.sdk.on('sensor-data', (event) => {
                    const data = event.detail || event;
                    if (this.gameState === 'playing' && this.players[data.sensorId]) {
                        this.updatePlayerPosition(data.sensorId, data.data.orientation);
                    }
                });

                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ë¥¼ ìœ„í•´ ì°¸ì¡° ì €ì¥)
                window.addEventListener('resize', this.boundEventListeners.resize, false);
                window.addEventListener('beforeunload', this.boundEventListeners.beforeunload, false);
            }

            displaySessionInfo(session) {
                document.getElementById('sessionCode').textContent = session.sessionCode;
                const qrUrl = `${window.location.origin}/sensor.html?session=${session.sessionCode}`;
                const qrContainer = document.getElementById('qrContainer');
                qrContainer.innerHTML = '';

                try {
                    if (typeof qrcode !== 'undefined') {
                        const qr = qrcode(0, 'L');
                        qr.addData(qrUrl);
                        qr.make();
                        qrContainer.innerHTML = qr.createImgTag(4);
                    } else { throw new Error('qrcode.js not loaded'); }
                } catch (e) {
                    console.warn('QR code generator failed, using fallback API.');
                    const img = document.createElement('img');
                    img.src = `https://api.qrserver.com/v1/create-qr-code/?size=160x160&data=${encodeURIComponent(qrUrl)}`;
                    qrContainer.appendChild(img);
                }
            }
            
            // ì•ˆì „í•œ íƒ€ì´ë¨¸ ê´€ë¦¬ í•¨ìˆ˜ë“¤
            safeSetTimeout(callback, delay) {
                const timeoutId = setTimeout(() => {
                    callback();
                    // ì™„ë£Œëœ íƒ€ì´ë¨¸ëŠ” ë°°ì—´ì—ì„œ ì œê±°
                    this.activeTimeouts = this.activeTimeouts.filter(id => id !== timeoutId);
                }, delay);
                this.activeTimeouts.push(timeoutId);
                return timeoutId;
            }
            
            safeSetInterval(callback, delay) {
                const intervalId = setInterval(callback, delay);
                this.activeIntervals.push(intervalId);
                return intervalId;
            }
            
            clearAllTimers() {
                // ëª¨ë“  í™œì„± íƒ€ì´ë¨¸ ì •ë¦¬
                this.activeTimeouts.forEach(id => clearTimeout(id));
                this.activeIntervals.forEach(id => clearInterval(id));
                this.activeTimeouts = [];
                this.activeIntervals = [];
                console.log('ğŸ§¹ ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬ ì™„ë£Œ');
            }
            
            // ë©”ëª¨ë¦¬ ì •ë¦¬ í•¨ìˆ˜
            cleanup() {
                console.log('ğŸ§¹ ê²Œì„ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì‹œì‘');
                
                // íƒ€ì´ë¨¸ ì •ë¦¬
                this.clearAllTimers();
                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì •ë¦¬
                if (this.boundEventListeners) {
                    window.removeEventListener('resize', this.boundEventListeners.resize, false);
                    window.removeEventListener('beforeunload', this.boundEventListeners.beforeunload, false);
                }
                
                // 3D ë¦¬ì†ŒìŠ¤ ì •ë¦¬
                if (this.scene) {
                    this.scene.clear();
                }
                
                if (this.renderer) {
                    this.renderer.dispose();
                }
                
                // ê°ì²´ ì°¸ì¡° ì •ë¦¬
                this.players = {};
                this.cake = {};
                this.obstacles = [];
                
                // ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì •ë¦¬
                if (this.sensorSmoothing) {
                    this.sensorSmoothing.playerHistory = {};
                }
                
                console.log('ğŸ§¹ ê²Œì„ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ');
            }
            
            // ì„¼ì„œ ë°ì´í„° ìŠ¤ë¬´ë”© ì‹œìŠ¤í…œ
            initPlayerSensorHistory(sensorId) {
                if (!this.sensorSmoothing.playerHistory[sensorId]) {
                    this.sensorSmoothing.playerHistory[sensorId] = {
                        gammaHistory: [],
                        betaHistory: [],
                        smoothedGamma: 0,
                        smoothedBeta: 0,
                        lastSignificantGamma: 0,
                        lastSignificantBeta: 0
                    };
                }
            }
            
            smoothSensorData(sensorId, gamma, beta) {
                const history = this.sensorSmoothing.playerHistory[sensorId];
                if (!history) {
                    this.initPlayerSensorHistory(sensorId);
                    return { gamma: 0, beta: 0 };
                }
                
                // ë°ë“œì¡´ ì ìš© - ë¯¸ì„¸í•œ ë³€í™” ë¬´ì‹œ
                const gammaChange = Math.abs(gamma - history.lastSignificantGamma);
                const betaChange = Math.abs(beta - history.lastSignificantBeta);
                
                const finalGamma = gammaChange > this.sensorSmoothing.deadZone ? gamma : history.lastSignificantGamma;
                const finalBeta = betaChange > this.sensorSmoothing.deadZone ? beta : history.lastSignificantBeta;
                
                // ìœ ì˜ë¯¸í•œ ë³€í™”ê°€ ìˆì„ ë•Œë§Œ ê¸°ì¤€ê°’ ì—…ë°ì´íŠ¸
                if (gammaChange > this.sensorSmoothing.deadZone) {
                    history.lastSignificantGamma = gamma;
                }
                if (betaChange > this.sensorSmoothing.deadZone) {
                    history.lastSignificantBeta = beta;
                }
                
                // íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
                history.gammaHistory.push(finalGamma);
                history.betaHistory.push(finalBeta);
                
                // íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ
                if (history.gammaHistory.length > this.sensorSmoothing.historySize) {
                    history.gammaHistory.shift();
                    history.betaHistory.shift();
                }
                
                // ì´ë™ í‰ê·  ê³„ì‚°
                const avgGamma = history.gammaHistory.reduce((sum, val) => sum + val, 0) / history.gammaHistory.length;
                const avgBeta = history.betaHistory.reduce((sum, val) => sum + val, 0) / history.betaHistory.length;
                
                // ë¶€ë“œëŸ¬ìš´ ë³´ê°„ ì ìš©
                history.smoothedGamma += (avgGamma - history.smoothedGamma) * this.sensorSmoothing.smoothingFactor;
                history.smoothedBeta += (avgBeta - history.smoothedBeta) * this.sensorSmoothing.smoothingFactor;
                
                return {
                    gamma: history.smoothedGamma,
                    beta: history.smoothedBeta
                };
            }
            
            // ê²Œì„ ëª¨ë“œì— ë”°ë¥¸ ë„ë¡œ í­ ì„¤ì •
            updateRoadWidth(gameMode) {
                const roadWidth = gameMode === 'coop4' ? this.roadWidthConfig.coop4 : this.roadWidthConfig.normal;
                
                if (this.roadWidth !== roadWidth) {
                    this.roadWidth = roadWidth;
                    console.log(`ğŸ›£ï¸ ë„ë¡œ í­ ë³€ê²½: ${gameMode} ëª¨ë“œ â†’ ${roadWidth}`);
                    
                    // ë ˆë²¨ì„ ë‹¤ì‹œ ìƒì„±í•˜ì—¬ ìƒˆë¡œìš´ ë„ë¡œ í­ ì ìš©
                    if (this.gameState !== 'waiting') {
                        this.recreateLevel();
                    }
                }
            }
            
            // ë ˆë²¨ ì¬ìƒì„± (ë„ë¡œ í­ ë³€ê²½ ì‹œ)
            recreateLevel() {
                // ê¸°ì¡´ ë°”ë‹¥ ì œê±°
                const existingFloor = this.scene.getObjectByName('gameFloor');
                if (existingFloor) {
                    this.scene.remove(existingFloor);
                }
                
                // ê¸°ì¡´ ëª©ì ì§€ ì œê±°
                if (this.destination) {
                    this.scene.remove(this.destination);
                    this.destination = null;
                }
                
                // ìƒˆë¡œìš´ ë°”ë‹¥ ìƒì„±
                const floorGeometry = new THREE.PlaneGeometry(this.roadWidth, 100);
                const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = -0.5;
                floor.receiveShadow = true;
                floor.name = 'gameFloor';
                this.scene.add(floor);
                
                console.log(`ğŸ”„ ë ˆë²¨ ì¬ìƒì„±: ë„ë¡œ í­ ${this.roadWidth}`);
            }
            
            // ëª¨ë“œë³„ ì„¼ì„œ HUD ë™ì  ìƒì„±
            createSensorStatusHUD(playerCount) {
                const connectionStatus = document.getElementById('connectionStatus');
                if (!connectionStatus) return;
                
                // ê¸°ì¡´ ìƒíƒœ ì œê±°
                connectionStatus.innerHTML = '';
                
                // í”Œë ˆì´ì–´ ìˆ˜ì— ë”°ë¼ ì„¼ì„œ ìƒíƒœ HUD ìƒì„±
                for (let i = 1; i <= playerCount; i++) {
                    const playerStatusDiv = document.createElement('div');
                    playerStatusDiv.id = `player${i}Status`;
                    playerStatusDiv.className = 'player-status disconnected';
                    playerStatusDiv.textContent = `P${i}`;
                    connectionStatus.appendChild(playerStatusDiv);
                }
                
                console.log(`ğŸ® ì„¼ì„œ HUD ìƒì„±: ${playerCount}ëª… ëª¨ë“œ`);
            }
            
            // ì„¼ì„œIDì—ì„œ í”Œë ˆì´ì–´ ë²ˆí˜¸ ì¶”ì¶œ (ê³ ì • ìˆœì„œë¥¼ ìœ„í•´)
            getPlayerNumberFromSensorId(sensorId) {
                // ì„¼ì„œIDë¥¼ ì •ë ¬í•˜ì—¬ ì¼ê´€ëœ ìˆœì„œ ë³´ì¥
                const allSensorIds = Object.keys(this.players).concat([sensorId]).sort();
                const playerIndex = allSensorIds.indexOf(sensorId);
                return playerIndex + 1; // 1P, 2P, 3P, 4P
            }

            addPlayer(sensorId) {
                // ì„¼ì„œ ë°ì´í„° ìŠ¤ë¬´ë”© íˆìŠ¤í† ë¦¬ ì´ˆê¸°í™”
                this.initPlayerSensorHistory(sensorId);
                
                // ì„¼ì„œID ê¸°ë°˜ìœ¼ë¡œ ê³ ì •ëœ í”Œë ˆì´ì–´ ë²ˆí˜¸ ê²°ì •
                const playerNumber = this.getPlayerNumberFromSensorId(sensorId);
                const playerLabel = `${playerNumber}P`;
                
                // í”Œë ˆì´ì–´ë³„ ìƒ‰ìƒ ì„¤ì • (ë²ˆí˜¸ ê¸°ë°˜)
                const playerColors = [0x3b82f6, 0x8b5cf6, 0x10b981, 0xf59e0b]; // íŒŒë‘, ë³´ë¼, ì´ˆë¡, ì£¼í™©
                const playerColor = playerColors[playerNumber - 1] || 0x6b7280;
                
                // í˜„ì¬ ì—°ê²°ëœ í”Œë ˆì´ì–´ ìˆ˜
                const currentPlayerCount = Object.keys(this.players).length;
                
                // 2ì¸ ëª¨ë“œì™€ 4ì¸ ëª¨ë“œì— ë”°ë¥¸ ì‹œì‘ ìœ„ì¹˜ (í”Œë ˆì´ì–´ ë²ˆí˜¸ ê¸°ë°˜)
                let startX;
                if (this.gameMode === 'coop4') {
                    // 4ì¸ ëª¨ë“œ: í”Œë ˆì´ì–´ ë²ˆí˜¸ì— ë”°ë¥¸ ê³ ì • ìœ„ì¹˜
                    const tempPositions = [-3, 3, -3, 3]; // 1P, 2P, 3P, 4P ìˆœì„œ
                    startX = tempPositions[playerNumber - 1] || 0;
                } else {
                    // 2ì¸ ëª¨ë“œ: í”Œë ˆì´ì–´ ë²ˆí˜¸ì— ë”°ë¥¸ ì¢Œìš° ë°°ì¹˜
                    startX = playerNumber === 1 ? -3 : 3;
                }
                
                console.log(`ğŸ‘¤ í”Œë ˆì´ì–´ ${playerLabel} ìƒì„± (${currentPlayerCount + 1}/${this.gameMode === 'coop4' ? 4 : 2})`);
                console.log(`ğŸ¨ ìƒ‰ìƒ: ${playerColor.toString(16)}, ì‹œì‘ìœ„ì¹˜: ${startX}`);

                // ì‚¬ëŒ ëª¨ìŠµ ìºë¦­í„° ìƒì„±
                console.log(`ğŸ‘¤ ì‚¬ëŒ ëª¨ìŠµ ëª¨ë¸ë¡œ í”Œë ˆì´ì–´ ${playerLabel} ìƒì„±`);
                
                // ìºë¦­í„° ê·¸ë£¹ ìƒì„±
                const characterGroup = new THREE.Group();
                let playerMesh;
                
                // ì¬ì§ˆ ì •ì˜ (í”Œë ˆì´ì–´ë³„ ìƒ‰ìƒ ì ìš©)
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: playerColor,
                    roughness: 0.3,
                    metalness: 0.1
                });
                const headMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xfdbcb4, // ì‚´ìƒ‰
                    roughness: 0.4,
                    metalness: 0.1
                });
                
                // ë¨¸ë¦¬ (êµ¬)
                const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.set(0, 1.25, 0);
                head.castShadow = true;
                characterGroup.add(head);
                
                // ëª¸í†µ (ì›í†µ)
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.35, 0.8, 16);
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.set(0, 0.6, 0);
                body.castShadow = true;
                characterGroup.add(body);
                
                // íŒ” (ì¢Œ)
                const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.6, 8);
                const leftArm = new THREE.Mesh(armGeometry, bodyMaterial);
                leftArm.position.set(-0.45, 0.7, 0);
                leftArm.rotation.z = Math.PI * 0.1; // ì•½ê°„ ë²Œë¦° ìì„¸
                leftArm.castShadow = true;
                characterGroup.add(leftArm);
                
                // íŒ” (ìš°)
                const rightArm = new THREE.Mesh(armGeometry, bodyMaterial);
                rightArm.position.set(0.45, 0.7, 0);
                rightArm.rotation.z = -Math.PI * 0.1; // ì•½ê°„ ë²Œë¦° ìì„¸
                rightArm.castShadow = true;
                characterGroup.add(rightArm);
                
                // ë‹¤ë¦¬ (ì¢Œ)
                const legGeometry = new THREE.CylinderGeometry(0.1, 0.12, 0.7, 8);
                const leftLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                leftLeg.position.set(-0.15, -0.15, 0);
                leftLeg.castShadow = true;
                characterGroup.add(leftLeg);
                
                // ë‹¤ë¦¬ (ìš°)
                const rightLeg = new THREE.Mesh(legGeometry, bodyMaterial);
                rightLeg.position.set(0.15, -0.15, 0);
                rightLeg.castShadow = true;
                characterGroup.add(rightLeg);
                
                // ë°œ (ì¢Œ)
                const footGeometry = new THREE.BoxGeometry(0.25, 0.1, 0.4);
                const footMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 }); // ê²€ì€ìƒ‰ ì‹ ë°œ
                const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
                leftFoot.position.set(-0.15, -0.55, 0.1);
                leftFoot.castShadow = true;
                characterGroup.add(leftFoot);
                
                // ë°œ (ìš°)
                const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
                rightFoot.position.set(0.15, -0.55, 0.1);
                rightFoot.castShadow = true;
                characterGroup.add(rightFoot);
                
                playerMesh = characterGroup;
                
                playerMesh.position.set(startX, 0, 0);

                // í”Œë ˆì´ì–´ ìƒ‰ìƒì— ë§ëŠ” ë¼ë²¨ ìƒ‰ìƒ ê³„ì‚°
                const labelColor = {
                    r: ((playerColor >> 16) & 255) / 255,
                    g: ((playerColor >> 8) & 255) / 255, 
                    b: (playerColor & 255) / 255,
                    a: 1.0
                };
                
                const labelSprite = this.makeTextSprite(playerLabel, { 
                    fontsize: 96, 
                    fontface: 'Arial Black', 
                    borderColor: labelColor,
                    backgroundColor: { r: 0, g: 0, b: 0, a: 0.7 } // ë°˜íˆ¬ëª… ê²€ì€ ë°°ê²½
                });
                
                // ìºë¦­í„° ë†’ì´ ìœ„ì— ë¼ë²¨ ë°°ì¹˜
                const box = new THREE.Box3().setFromObject(playerMesh);
                const labelHeight = (box.max.y - box.min.y) + 0.3;
                
                labelSprite.position.set(0, labelHeight, 0);
                labelSprite.userData.isLabel = true;
                playerMesh.add(labelSprite);
                
                console.log(`ğŸ·ï¸ ë¼ë²¨ ${playerLabel} ì¶”ê°€:`, {
                    labelPosition: { x: labelSprite.position.x, y: labelSprite.position.y, z: labelSprite.position.z },
                    labelHeight: labelHeight,
                    parentMesh: playerMesh.type,
                    parentChildren: playerMesh.children.length
                });

                this.scene.add(playerMesh);

                this.players[sensorId] = {
                    id: sensorId,
                    mesh: playerMesh,
                    velocity: new THREE.Vector3()
                };
                
                // í”Œë ˆì´ì–´ ìƒì„± í›„ ë””ë²„ê¹…
                console.log(`ğŸ¯ í”Œë ˆì´ì–´ ${playerLabel} ìƒì„± ì™„ë£Œ:`, {
                    sensorId: sensorId,
                    startPosition: { x: startX, y: 0, z: 0 },
                    actualPosition: { x: playerMesh.position.x, y: playerMesh.position.y, z: playerMesh.position.z },
                    meshType: playerMesh.type,
                    childrenCount: playerMesh.children?.length || 0,
                    hasLabel: playerMesh.children.some(child => child.userData && child.userData.isLabel)
                });

                // ëª¨ë“œì— ë”°ë¥¸ í•„ìš” í”Œë ˆì´ì–´ ìˆ˜ í™•ì¸
                const requiredPlayers = this.modeConfig[this.gameMode].players;
                if (Object.keys(this.players).length === requiredPlayers && !this.cake.mesh) {
                    this.createCake();
                    this.createLevel();
                }
                
                // 4ì¸ í˜‘ë™ ëª¨ë“œì—ì„œ í”Œë ˆì´ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (this.gameMode === 'coop4') {
                    this.updateCoop4PlayerStatus();
                }
            }

            removePlayer(sensorId) {
                if (this.players[sensorId]) {
                    this.scene.remove(this.players[sensorId].mesh);
                    delete this.players[sensorId];
                    
                    // ì„¼ì„œ íˆìŠ¤í† ë¦¬ë„ ì •ë¦¬
                    if (this.sensorSmoothing.playerHistory[sensorId]) {
                        delete this.sensorSmoothing.playerHistory[sensorId];
                        console.log(`ğŸ§¹ ${sensorId} ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì •ë¦¬ ì™„ë£Œ`);
                    }
                    
                    this.setGameState('fail', 'í”Œë ˆì´ì–´ ì—°ê²° ëŠê¹€!');
                }
            }

            updatePlayerStatus() {
                const currentPlayerCount = Object.keys(this.players).length;
                const requiredPlayerCount = this.modeConfig[this.gameMode].players;
                
                // ëª¨ë“  í”Œë ˆì´ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë™ì ìœ¼ë¡œ ìƒì„±ëœ ì„¼ì„œ HUD)
                for (let i = 1; i <= requiredPlayerCount; i++) {
                    const statusElement = document.getElementById(`player${i}Status`);
                    if (statusElement) {
                        const isConnected = i <= currentPlayerCount;
                        statusElement.className = `player-status ${isConnected ? 'connected' : 'disconnected'}`;
                    }
                }
                
                // 4ì¸ í˜‘ë™ ëª¨ë“œì¼ ë•Œ ì¶”ê°€ ìƒíƒœ ë©”ì‹œì§€ í‘œì‹œ
                if (this.gameMode === 'coop4') {
                    this.updateCoop4PlayerStatus();
                }
                
                console.log(`ğŸ‘¥ ì„¼ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸: ${currentPlayerCount}/${requiredPlayerCount}ëª… ì—°ê²°ë¨`);
            }

            // 4ì¸ í˜‘ë™ ëª¨ë“œ í”Œë ˆì´ì–´ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateCoop4PlayerStatus() {
                const playerCount = Object.keys(this.players).length;
                const statusText = `${playerCount}/4ëª… ì—°ê²°ë¨`;
                
                // ë©”ì‹œì§€ ë°•ìŠ¤ì— ì—°ê²° ìƒíƒœ í‘œì‹œ
                if (playerCount < 4 && this.gameState === 'waiting') {
                    this.messageBox.textContent = `ğŸ‘¥ 4ì¸ í˜‘ë™ ëª¨ë“œ - ${statusText}`;
                } else if (playerCount === 4 && this.gameState === 'waiting' && this.cake.mesh) {
                    this.setGameState('ready', '4ëª… ëª¨ë‘ ì—°ê²°ë¨! ê²Œì„ ì‹œì‘!');
                    this.safeSetTimeout(() => {
                        this.setGameState('playing', '');
                    }, 3000);
                }
                
                console.log(`ğŸ‘¥ 4ì¸ í˜‘ë™ ëª¨ë“œ: ${statusText}`);
            }

            createCake() {
                // ì„ íƒëœ ì¼€ì´í¬ íƒ€ì… ì‚¬ìš©
                if (this.selectedCakeType === 'random') {
                    const cakeTypes = Object.keys(this.cakeConfig);
                    this.currentCakeType = cakeTypes[Math.floor(Math.random() * cakeTypes.length)];
                } else {
                    this.currentCakeType = this.selectedCakeType;
                }
                
                const config = this.cakeConfig[this.currentCakeType];
                
                // 4ì¸ í˜‘ë™ ëª¨ë“œì—ì„œëŠ” ì¼€ì´í¬ í¬ê¸° 2ë°° ì¦ê°€
                const sizeMultiplier = this.gameMode === 'coop4' ? 2.0 : 1.0;
                const adjustedSize = config.size * sizeMultiplier;
                
                console.log(`ğŸ‚ ì¼€ì´í¬ ìƒì„±: ${this.currentCakeType}, í¬ê¸°ë°°ìœ¨: ${sizeMultiplier}x, ìµœì¢…í¬ê¸°: ${adjustedSize}`);
                
                // ì¼€ì´í¬ ê·¸ë£¹ ìƒì„±
                const cakeGroup = new THREE.Group();
                
                // ì¼€ì´í¬ ì¸µ ìƒì„±
                const layerHeight = 0.4 * sizeMultiplier; // 4ì¸ ëª¨ë“œì—ì„œëŠ” ì¸µë„ ë‘êº¼ì›Œì§
                const colors = [config.color, config.color * 0.9, config.color * 0.8];
                
                for (let i = 0; i < config.layers; i++) {
                    const layerRadius = adjustedSize * (1 - i * 0.1);
                    const layerGeometry = new THREE.CylinderGeometry(layerRadius, layerRadius, layerHeight, 32);
                    const layerMaterial = new THREE.MeshStandardMaterial({ 
                        color: colors[i] || config.color,
                        roughness: 0.3,
                        metalness: 0.1
                    });
                    
                    const layer = new THREE.Mesh(layerGeometry, layerMaterial);
                    layer.position.y = i * layerHeight;
                    layer.castShadow = true;
                    cakeGroup.add(layer);
                }
                
                // ì¼€ì´í¬ ì¥ì‹ ì¶”ê°€
                this.addCakeDecorations(cakeGroup, config);
                
                this.cake.mesh = cakeGroup;
                this.cake.mesh.castShadow = true;
                this.scene.add(this.cake.mesh);
                
                // ì¼€ì´í¬ íƒ€ì…ë³„ ë¬¼ë¦¬ ìƒíƒœ ì´ˆê¸°í™”
                this.initializeCakePhysics(config);
                
                // ì¼€ì´í¬ ì •ë³´ UI ì—…ë°ì´íŠ¸
                this.updateCakeInfo();
            }
            
            addCakeDecorations(cakeGroup, config) {
                // ì¼€ì´í¬ íƒ€ì…ë³„ ì¥ì‹ ì¶”ê°€
                switch(this.currentCakeType) {
                    case 'strawberry':
                        // ë”¸ê¸° ì¥ì‹ ì¶”ê°€
                        for (let i = 0; i < 6; i++) {
                            const strawberryGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                            const strawberryMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                            const strawberry = new THREE.Mesh(strawberryGeometry, strawberryMaterial);
                            
                            const angle = (i / 6) * Math.PI * 2;
                            strawberry.position.set(
                                Math.cos(angle) * config.size * 0.7,
                                config.layers * 0.4,
                                Math.sin(angle) * config.size * 0.7
                            );
                            cakeGroup.add(strawberry);
                        }
                        break;
                        
                    case 'chocolate':
                        // ì´ˆì½œë¦¿ ì¹© ì¥ì‹
                        for (let i = 0; i < 8; i++) {
                            const chipGeometry = new THREE.BoxGeometry(0.1, 0.05, 0.1);
                            const chipMaterial = new THREE.MeshStandardMaterial({ color: 0x2d1b14 });
                            const chip = new THREE.Mesh(chipGeometry, chipMaterial);
                            
                            chip.position.set(
                                (Math.random() - 0.5) * config.size * 1.5,
                                Math.random() * config.layers * 0.4,
                                (Math.random() - 0.5) * config.size * 1.5
                            );
                            cakeGroup.add(chip);
                        }
                        break;
                        
                    case 'wedding':
                        // ê½ƒ ì¥ì‹
                        for (let layer = 0; layer < config.layers; layer++) {
                            const flowerGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                            const flowerMaterial = new THREE.MeshStandardMaterial({ color: 0xffc0cb });
                            const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
                            
                            flower.position.set(
                                config.size * (1 - layer * 0.1),
                                layer * 0.4 + 0.2,
                                0
                            );
                            cakeGroup.add(flower);
                        }
                        break;
                        
                    case 'ice':
                        // ì–¼ìŒ íš¨ê³¼ (ë°˜íˆ¬ëª…)
                        const iceGeometry = new THREE.SphereGeometry(config.size * 0.3, 16, 16);
                        const iceMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x87ceeb,
                            transparent: true,
                            opacity: 0.6
                        });
                        const ice = new THREE.Mesh(iceGeometry, iceMaterial);
                        ice.position.y = config.layers * 0.4;
                        cakeGroup.add(ice);
                        break;
                        
                    case 'bomb':
                        // í­íƒ„ ì‹¬ì§€
                        const fuseGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
                        const fuseMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                        const fuse = new THREE.Mesh(fuseGeometry, fuseMaterial);
                        fuse.position.y = config.layers * 0.4 + 0.3;
                        cakeGroup.add(fuse);
                        
                        // íƒ€ì´ë¨¸ í‘œì‹œ
                        const timerGeometry = new THREE.RingGeometry(0.3, 0.4, 16);
                        const timerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                        const timer = new THREE.Mesh(timerGeometry, timerMaterial);
                        timer.rotation.x = -Math.PI / 2;
                        timer.position.y = config.layers * 0.4 + 0.1;
                        cakeGroup.add(timer);
                        break;
                }
            }
            
            initializeCakePhysics(config) {
                // ì¼€ì´í¬ íƒ€ì…ë³„ ë¬¼ë¦¬ ì´ˆê¸°í™”
                this.cakePhysics.instability = 1.0 - config.stability;
                this.cakePhysics.temperature = 20;
                this.cakePhysics.volume = 1.0;
                this.cakePhysics.density = config.weight;
                this.cakePhysics.elasticity = config.stability * 0.5;
                this.cakePhysics.viscosity = 0.1;
                
                // ì†ë„ ì´ˆê¸°í™”
                this.cakePhysics.velocity.set(0, 0, 0);
                this.cakePhysics.angularVelocity.set(0, 0, 0);
                
                switch(this.currentCakeType) {
                    case 'ice':
                        this.cakePhysics.meltingTimer = 60; // 60ì´ˆ í›„ ë…¹ìŒ
                        this.cakePhysics.temperature = -10;
                        this.cakePhysics.viscosity = 0.05; // ë” ë‹¨ë‹¨í•¨
                        break;
                    case 'bomb':
                        this.cakePhysics.bombTimer = 30; // 30ì´ˆ íƒ€ì´ë¨¸
                        this.cakePhysics.instability += 0.2; // ì¶”ê°€ ë¶ˆì•ˆì •ì„±
                        break;
                    case 'chocolate':
                        this.cakePhysics.viscosity = 0.15; // ë” ëˆì í•¨
                        break;
                    case 'wedding':
                        this.cakePhysics.instability += 0.3; // ë†’ì€ ì¸µìœ¼ë¡œ ë¶ˆì•ˆì •
                        break;
                    default:
                        this.cakePhysics.meltingTimer = 0;
                        this.cakePhysics.bombTimer = 0;
                }
            }
            
            updateCakeInfo() {
                const cakeInfoDiv = document.getElementById('cakeInfo');
                if (!cakeInfoDiv || !this.currentCakeType || !this.cakePhysics) return;
                
                // ì„±ëŠ¥ ìµœì í™”: ê²Œì„ì´ í”Œë ˆì´ ì¤‘ì¼ ë•Œë§Œ ì—…ë°ì´íŠ¸
                if (this.gameState !== 'playing') return;
                
                const config = this.cakeConfig[this.currentCakeType];
                const cakeNames = {
                    basic: 'ê¸°ë³¸ ì¼€ì´í¬',
                    strawberry: 'ë”¸ê¸° ì¼€ì´í¬',
                    chocolate: 'ì´ˆì½œë¦¿ ì¼€ì´í¬', 
                    wedding: 'ì›¨ë”© ì¼€ì´í¬',
                    ice: 'ì•„ì´ìŠ¤í¬ë¦¼ ì¼€ì´í¬',
                    bomb: 'í­íƒ„ ì¼€ì´í¬'
                };
                
                // ì „ì²´ ìƒíƒœ í‘œì‹œê¸°
                const overallStatus = this.getCakeOverallStatus();
                const statusIndicator = `<span class="status-indicator ${overallStatus.class}"></span>`;
                
                let statusText = `${statusIndicator}ğŸ‚ ${cakeNames[this.currentCakeType] || 'ì•Œ ìˆ˜ ì—†ìŒ'}`;
                statusText += `<br>í¬ê¸°: ${config.size.toFixed(1)} | ë¬´ê²Œ: ${config.weight.toFixed(1)} | ì•ˆì •ì„±: ${this.getStabilityDisplay(config.stability)}`;
                
                // ë¬¼ë¦¬ ìƒíƒœ í‘œì‹œ (ìƒ‰ìƒ ì½”ë”©)
                statusText += `<br>ğŸŒ¡ï¸ ì˜¨ë„: ${this.getTemperatureDisplay()} | íƒ„ì„±: ${this.cakePhysics.elasticity.toFixed(2)}`;
                statusText += `<br>ğŸ’§ ì ì„±: ${this.cakePhysics.viscosity.toFixed(2)} | ë¶€í”¼: ${this.getVolumeDisplay()}`;
                
                // íŠ¹ìˆ˜ ìƒíƒœ í‘œì‹œ (ê°œì„ ëœ ì‹œê°ì  í”¼ë“œë°±)
                if (this.currentCakeType === 'ice' && this.cakePhysics.meltingTimer > 0) {
                    const timeLeft = this.cakePhysics.meltingTimer;
                    const urgency = this.getUrgencyLevel(timeLeft, 60);
                    statusText += `<br>${urgency.icon} ë…¹ê¸°ê¹Œì§€: <span style="color: ${urgency.color}">${timeLeft.toFixed(1)}ì´ˆ</span>`;
                }
                
                if (this.currentCakeType === 'bomb' && this.cakePhysics.bombTimer > 0) {
                    const timeLeft = this.cakePhysics.bombTimer;
                    const urgency = this.getUrgencyLevel(timeLeft, 30);
                    statusText += `<br>${urgency.icon} í­ë°œê¹Œì§€: <span style="color: ${urgency.color}">${timeLeft.toFixed(1)}ì´ˆ</span>`;
                }
                
                // ë°”ëŒ íš¨ê³¼ í‘œì‹œ
                const levelConfig = this.levelConfig[this.level];
                if (levelConfig?.wind > 0) {
                    const windStrength = this.getWindStrengthDisplay(levelConfig.wind);
                    statusText += `<br>ğŸ’¨ ë°”ëŒ: ${windStrength}`;
                }
                
                // í™˜ê²½ ì •ë³´ í‘œì‹œ
                const envConfig = this.environmentConfig[this.currentEnvironment];
                if (envConfig) {
                    statusText += `<br>ğŸŒ í™˜ê²½: ${envConfig.name}`;
                }
                
                cakeInfoDiv.innerHTML = statusText;
            }
            
            getCakeOverallStatus() {
                const instability = this.cakePhysics.instability;
                if (instability > 0.7) return { class: 'danger', text: 'ìœ„í—˜' };
                if (instability > 0.4) return { class: 'warning', text: 'ì£¼ì˜' };
                return { class: 'good', text: 'ì•ˆì •' };
            }
            
            getStabilityDisplay(stability) {
                const value = stability.toFixed(1);
                if (stability > 0.8) return `<span style="color: var(--success)">${value}</span>`;
                if (stability > 0.5) return `<span style="color: var(--warning)">${value}</span>`;
                return `<span style="color: var(--error)">${value}</span>`;
            }
            
            getTemperatureDisplay() {
                const temp = this.cakePhysics.temperature;
                const value = temp.toFixed(1) + 'Â°C';
                if (temp > 30) return `<span style="color: var(--error)">${value}</span>`;
                if (temp < 0) return `<span style="color: #87ceeb">${value}</span>`;
                return `<span style="color: var(--success)">${value}</span>`;
            }
            
            getVolumeDisplay() {
                const volume = this.cakePhysics.volume;
                const value = volume.toFixed(2);
                if (volume < 0.6) return `<span style="color: var(--error)">${value}</span>`;
                if (volume < 0.8) return `<span style="color: var(--warning)">${value}</span>`;
                return `<span style="color: var(--success)">${value}</span>`;
            }
            
            getUrgencyLevel(timeLeft, maxTime) {
                const ratio = timeLeft / maxTime;
                if (ratio < 0.3) return { icon: 'ğŸš¨', color: 'var(--error)' };
                if (ratio < 0.6) return { icon: 'âš ï¸', color: 'var(--warning)' };
                return { icon: 'â„ï¸', color: 'var(--success)' };
            }
            
            getWindStrengthDisplay(wind) {
                const value = wind.toFixed(1);
                if (wind > 0.3) return `<span style="color: var(--error)">${value} (ê°•í•¨)</span>`;
                if (wind > 0.1) return `<span style="color: var(--warning)">${value} (ë³´í†µ)</span>`;
                return `<span style="color: var(--success)">${value} (ì•½í•¨)</span>`;
            }
            
            applyEnvironment(environmentType) {
                const envConfig = this.environmentConfig[environmentType];
                
                // í•˜ëŠ˜ìƒ‰ ë³€ê²½
                this.renderer.setClearColor(envConfig.skyColor);
                
                // ì¡°ëª… ê°•ë„ ì¡°ì •
                this.scene.traverse((child) => {
                    if (child instanceof THREE.AmbientLight) {
                        child.intensity = envConfig.ambientLight;
                    }
                    if (child instanceof THREE.DirectionalLight) {
                        child.intensity = envConfig.directionalLight;
                    }
                });
                
                // ì•ˆê°œ íš¨ê³¼ ì ìš©
                this.scene.fog = new THREE.Fog(envConfig.skyColor, envConfig.fogNear, envConfig.fogFar);
                
                // ë°”ë‹¥ ìƒ‰ìƒ ë³€ê²½
                this.scene.traverse((child) => {
                    if (child instanceof THREE.Mesh && child.geometry instanceof THREE.PlaneGeometry) {
                        child.material.color.setHex(envConfig.floorColor);
                    }
                });
                
                // í™˜ê²½ë³„ íŠ¹ìˆ˜ íš¨ê³¼ ì¶”ê°€
                this.addEnvironmentEffects(environmentType);
                
                console.log(`ğŸŒ í™˜ê²½ ë³€ê²½: ${envConfig.name}`);
            }
            
            addEnvironmentEffects(environmentType) {
                // ê¸°ì¡´ í™˜ê²½ íš¨ê³¼ ì œê±°
                this.clearEnvironmentEffects();
                
                // í™˜ê²½ íš¨ê³¼ ê°ì²´ ë°°ì—´ ì´ˆê¸°í™”
                this.environmentEffectsObjects = [];
                
                switch(environmentType) {
                    case 'forest':
                        this.createForestEffects();
                        break;
                    case 'desert':
                        this.createDesertEffects();
                        break;
                    case 'beach':
                        this.createBeachEffects();
                        break;
                    case 'winter':
                        this.createWinterEffects();
                        break;
                    case 'night':
                        this.createNightEffects();
                        break;
                }
            }
            
            clearEnvironmentEffects() {
                // ê¸°ì¡´ í™˜ê²½ íš¨ê³¼ ì œê±° (ë” íš¨ìœ¨ì ì¸ ë°©ë²•)
                const toRemove = [];
                this.scene.children.forEach(child => {
                    if (child.userData.isEnvironmentEffect) {
                        toRemove.push(child);
                    }
                });
                
                toRemove.forEach(child => {
                    this.scene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                });
                
                this.environmentEffectsObjects = [];
            }
            
            createForestEffects() {
                // ë‚˜ë¬´ ìƒì„±
                for (let i = 0; i < 20; i++) {
                    const treeGroup = new THREE.Group();
                    treeGroup.userData.isEnvironmentEffect = true;
                    
                    // ë‚˜ë¬´ ì¤„ê¸°
                    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 4, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2;
                    trunk.castShadow = true;
                    
                    // ë‚˜ë¬´ ì
                    const leavesGeometry = new THREE.SphereGeometry(2, 8, 8);
                    const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.y = 4;
                    leaves.castShadow = true;
                    
                    treeGroup.add(trunk);
                    treeGroup.add(leaves);
                    
                    // ë„ë¡œ ì–‘ìª½ì— ë°°ì¹˜
                    const side = Math.random() > 0.5 ? 1 : -1;
                    treeGroup.position.set(
                        side * (this.roadWidth/2 + 3 + Math.random() * 5),
                        0,
                        -Math.random() * 100
                    );
                    
                    this.scene.add(treeGroup);
                    this.environmentEffectsObjects.push(treeGroup);
                }
            }
            
            createDesertEffects() {
                // ì„ ì¸ì¥ ìƒì„±
                for (let i = 0; i < 15; i++) {
                    const cactusGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
                    const cactusMaterial = new THREE.MeshStandardMaterial({ color: 0x228b22 });
                    const cactus = new THREE.Mesh(cactusGeometry, cactusMaterial);
                    cactus.userData.isEnvironmentEffect = true;
                    cactus.castShadow = true;
                    
                    const side = Math.random() > 0.5 ? 1 : -1;
                    cactus.position.set(
                        side * (this.roadWidth/2 + 2 + Math.random() * 8),
                        1.5,
                        -Math.random() * 100
                    );
                    
                    this.scene.add(cactus);
                    this.environmentEffectsObjects.push(cactus);
                }
            }
            
            createBeachEffects() {
                // ì•¼ììˆ˜ ìƒì„±
                for (let i = 0; i < 10; i++) {
                    const palmGroup = new THREE.Group();
                    palmGroup.userData.isEnvironmentEffect = true;
                    
                    // ì•¼ììˆ˜ ì¤„ê¸°
                    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 5, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 2.5;
                    trunk.castShadow = true;
                    
                    // ì•¼ììˆ˜ ì
                    for (let j = 0; j < 6; j++) {
                        const leafGeometry = new THREE.PlaneGeometry(1, 4);
                        const leafMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0x228b22,
                            side: THREE.DoubleSide
                        });
                        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
                        leaf.position.y = 4.5;
                        leaf.rotation.y = (j / 6) * Math.PI * 2;
                        leaf.rotation.x = -Math.PI / 6;
                        palmGroup.add(leaf);
                    }
                    
                    palmGroup.add(trunk);
                    
                    const side = Math.random() > 0.5 ? 1 : -1;
                    palmGroup.position.set(
                        side * (this.roadWidth/2 + 3 + Math.random() * 6),
                        0,
                        -Math.random() * 100
                    );
                    
                    this.scene.add(palmGroup);
                    this.environmentEffectsObjects.push(palmGroup);
                }
            }
            
            createWinterEffects() {
                // ëˆˆ íŒŒí‹°í´ ìƒì„±
                const snowGeometry = new THREE.BufferGeometry();
                const snowMaterial = new THREE.PointsMaterial({ 
                    color: 0xffffff, 
                    size: 0.1,
                    transparent: true,
                    opacity: 0.8
                });
                
                const snowVertices = [];
                for (let i = 0; i < 5000; i++) {
                    snowVertices.push(
                        (Math.random() - 0.5) * 200,
                        Math.random() * 50,
                        (Math.random() - 0.5) * 200
                    );
                }
                
                snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowVertices, 3));
                const snow = new THREE.Points(snowGeometry, snowMaterial);
                snow.userData.isEnvironmentEffect = true;
                snow.userData.isSnow = true;
                this.scene.add(snow);
                this.environmentEffectsObjects.push(snow);
                
                // ëˆˆ ë®ì¸ ë‚˜ë¬´
                for (let i = 0; i < 15; i++) {
                    const treeGeometry = new THREE.ConeGeometry(1.5, 4, 8);
                    const treeMaterial = new THREE.MeshStandardMaterial({ color: 0x006400 });
                    const tree = new THREE.Mesh(treeGeometry, treeMaterial);
                    tree.userData.isEnvironmentEffect = true;
                    tree.castShadow = true;
                    
                    const side = Math.random() > 0.5 ? 1 : -1;
                    tree.position.set(
                        side * (this.roadWidth/2 + 2 + Math.random() * 7),
                        2,
                        -Math.random() * 100
                    );
                    
                    this.scene.add(tree);
                    this.environmentEffectsObjects.push(tree);
                }
            }
            
            createNightEffects() {
                // ê°€ë¡œë“± ìƒì„±
                for (let i = 0; i < 20; i++) {
                    const lampGroup = new THREE.Group();
                    lampGroup.userData.isEnvironmentEffect = true;
                    
                    // ê°€ë¡œë“± ê¸°ë‘¥
                    const poleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 6, 8);
                    const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                    pole.position.y = 3;
                    
                    // ê°€ë¡œë“± ì¡°ëª…
                    const lightGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                    const lightMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    const light = new THREE.Mesh(lightGeometry, lightMaterial);
                    light.position.y = 5.5;
                    
                    // ì ê´‘ì› ì¶”ê°€
                    const pointLight = new THREE.PointLight(0xffff00, 1, 10);
                    pointLight.position.y = 5.5;
                    pointLight.castShadow = true;
                    
                    lampGroup.add(pole);
                    lampGroup.add(light);
                    lampGroup.add(pointLight);
                    
                    lampGroup.position.set(
                        (this.roadWidth/2 + 1),
                        0,
                        -i * 5
                    );
                    
                    this.scene.add(lampGroup);
                    this.environmentEffectsObjects.push(lampGroup);
                }
            }
            
            createLevel() {
                // ê¸°ì¡´ ì¥ì• ë¬¼ ë° êµ¬ë© ì œê±°
                this.obstacles.forEach(obstacle => this.scene.remove(obstacle));
                this.obstacles = [];

                const config = this.levelConfig[this.level];
                const totalLength = 100; // ëª©ì ì§€ê¹Œì§€ì˜ ì´ ê¸¸ì´
                const destinationZ = -totalLength; // ëª©ì ì§€ Z ì¢Œí‘œ
                
                // í™˜ê²½ ì„¤ì • ì ìš©
                this.currentEnvironment = config.theme || 'normal';
                this.applyEnvironment(this.currentEnvironment);

                // ê³ ì • ì¥ì• ë¬¼ ìƒì„±
                const obstacleGeometry = new THREE.BoxGeometry(2, 2, 2);
                for(let i = 0; i < config.obstacles; i++) {
                    const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xef4444 });
                    const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                    obstacle.position.set(Math.random() * (this.roadWidth - 4) - (this.roadWidth / 2 - 2), 0, -10 - i * (totalLength / config.obstacles));
                    obstacle.castShadow = true;
                    this.scene.add(obstacle);
                    this.obstacles.push(obstacle);
                }

                // êµ¬ë© ìƒì„± (ë‹¨ìˆœíˆ ì–´ë‘ìš´ í‰ë©´ìœ¼ë¡œ í‘œí˜„)
                const holeGeometry = new THREE.PlaneGeometry(3, 3);
                const holeMaterial = new THREE.MeshStandardMaterial({ color: 0x1a202c });
                for(let i = 0; i < config.holes; i++) {
                    const hole = new THREE.Mesh(holeGeometry, holeMaterial);
                    hole.rotation.x = -Math.PI / 2;
                    hole.position.set(Math.random() * (this.roadWidth - 4) - (this.roadWidth / 2 - 2), -0.45, -5 - i * (totalLength / config.holes));
                    this.scene.add(hole);
                    this.obstacles.push(hole); // êµ¬ë©ë„ ì¶©ëŒ ì²´í¬ ëŒ€ìƒì— í¬í•¨
                }

                // ì›€ì§ì´ëŠ” ì¥ì• ë¬¼ ìƒì„±
                const movingObstacleGeometry = new THREE.BoxGeometry(3, 1, 1);
                const movingObstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
                for(let i = 0; i < config.movingObstacles; i++) {
                    const movingObstacle = new THREE.Mesh(movingObstacleGeometry, movingObstacleMaterial);
                    movingObstacle.position.set(0, 0, -25 - i * (totalLength / config.movingObstacles));
                    movingObstacle.userData.moveDirection = Math.random() > 0.5 ? 1 : -1;
                    movingObstacle.userData.moveSpeed = 0.1 + Math.random() * 0.1;
                    movingObstacle.castShadow = true;
                    this.scene.add(movingObstacle);
                    this.obstacles.push(movingObstacle);
                }

                // íšŒì „í•˜ëŠ” ì¥ì• ë¬¼ ìƒì„±
                const rotatingObstacleGeometry = new THREE.BoxGeometry(1, 5, 1);
                const rotatingObstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x8a2be2 });
                for(let i = 0; i < config.rotatingObstacles; i++) {
                    const rotatingObstacle = new THREE.Mesh(rotatingObstacleGeometry, rotatingObstacleMaterial);
                    rotatingObstacle.position.set(0, 2.5, -30 - i * (totalLength / config.rotatingObstacles));
                    rotatingObstacle.userData.rotationSpeed = 0.05 + Math.random() * 0.05;
                    rotatingObstacle.castShadow = true;
                    this.scene.add(rotatingObstacle);
                    this.obstacles.push(rotatingObstacle);
                }

                // ëª©ì ì§€ ìœ„ì¹˜ ì¡°ì •
                if (!this.destination) {
                    const destGeometry = new THREE.BoxGeometry(this.roadWidth, 1, 5);
                    const destMaterial = new THREE.MeshStandardMaterial({ color: 0x10b981, transparent: true, opacity: 0.5 });
                    this.destination = new THREE.Mesh(destGeometry, destMaterial);
                    this.scene.add(this.destination);
                }
                this.destination.position.set(0, -0.4, destinationZ);
            }

            updatePlayerPosition(sensorId, orientation) {
                const player = this.players[sensorId];
                if (!player) {
                    console.warn(`âš ï¸ í”Œë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: ${sensorId}`);
                    return;
                }

                // ì„¼ì„œ ë°ì´í„° ê²€ì¦ ê°•í™”
                if (!orientation || typeof orientation !== 'object') {
                    console.warn(`âš ï¸ ì˜ëª»ëœ ì„¼ì„œ ë°ì´í„°: ${sensorId}`, orientation);
                    return;
                }

                const config = this.levelConfig[this.level];
                const sensitivity = 0.02;
                const maxSpeed = 0.2;

                // NaN ë° ë¬´í•œê°’ í•„í„°ë§
                const gamma = (orientation.gamma || 0);
                const beta = (orientation.beta || 0);
                
                if (!isFinite(gamma) || !isFinite(beta)) {
                    console.warn(`âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ ì„¼ì„œ ê°’: gamma=${gamma}, beta=${beta}`);
                    return;
                }

                // ê·¹ê°’ ì œí•œ (-180 ~ 180ë„)
                const clampedGamma = THREE.MathUtils.clamp(gamma, -180, 180);
                const clampedBeta = THREE.MathUtils.clamp(beta, -180, 180);

                // ì„¼ì„œ ë°ì´í„° ìŠ¤ë¬´ë”© ì ìš©
                const smoothedData = this.smoothSensorData(sensorId, clampedGamma, clampedBeta);

                let moveX = smoothedData.gamma * sensitivity;
                let moveZ = smoothedData.beta * sensitivity;

                moveX = THREE.MathUtils.clamp(moveX, -maxSpeed, maxSpeed);
                moveZ = THREE.MathUtils.clamp(moveZ, -maxSpeed, maxSpeed);

                const targetVelocity = new THREE.Vector3(moveX, 0, moveZ - config.forwardSpeed);

                // ì´ì „ ìœ„ì¹˜ ì €ì¥
                const oldPosition = player.mesh.position.clone();
                
                // ë” ë¶€ë“œëŸ¬ìš´ ì†ë„ ë³´ê°„ (0.05 â†’ 0.08)
                player.velocity.lerp(targetVelocity, 0.08);
                
                // ìƒˆë¡œìš´ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                const targetPosition = oldPosition.clone().add(player.velocity);
                
                // ìœ„ì¹˜ë¥¼ ë¶€ë“œëŸ½ê²Œ ë³´ê°„ (ë–¨ë¦¼ ë°©ì§€)
                player.mesh.position.lerp(targetPosition, 0.7);

                // ë„ë¡œ ì´íƒˆ ë°©ì§€
                const roadLimit = this.roadWidth / 2 - 0.5;
                player.mesh.position.x = THREE.MathUtils.clamp(player.mesh.position.x, -roadLimit, roadLimit);
                player.mesh.position.z = THREE.MathUtils.clamp(player.mesh.position.z, -100, 2);
                
                // ìƒì„¸í•œ ë””ë²„ê¹… ë¡œê·¸
                const positionChanged = !oldPosition.equals(player.mesh.position);
                if (positionChanged || Math.abs(orientation.gamma) > 5 || Math.abs(orientation.beta) > 5) {
                    console.log(`ğŸ“± ì„¼ì„œ ë°ì´í„° ë° ìœ„ì¹˜ ë³€í™” (${sensorId}):`, {
                        // ì„¼ì„œ ë°ì´í„°
                        sensor: {
                            gamma: orientation.gamma?.toFixed(2),
                            beta: orientation.beta?.toFixed(2)
                        },
                        // ì´ë™ëŸ‰ ê³„ì‚°
                        movement: {
                            moveX: moveX.toFixed(4),
                            moveZ: moveZ.toFixed(4),
                            velocity: {
                                x: player.velocity.x.toFixed(4),
                                y: player.velocity.y.toFixed(4),
                                z: player.velocity.z.toFixed(4)
                            }
                        },
                        // ìœ„ì¹˜ ì •ë³´
                        position: {
                            old: { x: oldPosition.x.toFixed(2), y: oldPosition.y.toFixed(2), z: oldPosition.z.toFixed(2) },
                            new: { x: player.mesh.position.x.toFixed(2), y: player.mesh.position.y.toFixed(2), z: player.mesh.position.z.toFixed(2) },
                            changed: positionChanged
                        },
                        // í”Œë ˆì´ì–´ ì •ë³´
                        player: {
                            isGLBModel: player.isGLBModel,
                            meshType: player.mesh.type,
                            childrenCount: player.mesh.children?.length || 0,
                            hasUserData: !!player.mesh.userData,
                            meshConstructor: player.mesh.constructor.name
                        }
                    });
                }
            }

            updateCakePosition() {
                const playerCount = Object.keys(this.players).length;
                
                // 4ì¸ í˜‘ë™ ëª¨ë“œ
                if (this.gameMode === 'coop4') {
                    if (!this.cake.mesh || playerCount < 4) return;
                    this.updateCoop4CakePosition();
                    return;
                }
                
                // ì¼ë°˜ 2ëª… ëª¨ë“œ
                if (!this.cake.mesh || playerCount < 2) return;
                this.updateDualCakePosition();
            }
            
            // 2ëª… ëª¨ë“œ ì¼€ì´í¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateDualCakePosition() {
                const sortedPlayerIds = Object.keys(this.players).sort();
                const playerPositions = sortedPlayerIds.map(id => this.players[id].mesh.position);
                const p1 = playerPositions[0];
                const p2 = playerPositions[1];

                this.cake.mesh.position.lerp(new THREE.Vector3((p1.x + p2.x) / 2, 0, (p1.z + p2.z) / 2), 0.1);

                // ì¼€ì´í¬ íšŒì „ì€ ê³ ì •, ê¸°ìš¸ê¸°ë§Œ ê³„ì‚°
                this.cake.mesh.rotation.y = 0; // Yì¶• íšŒì „ ê³ ì •
                this.cake.mesh.rotation.x = (p1.z - p2.z) * 0.1;
                this.cake.mesh.rotation.z = (p2.x - p1.x) * 0.1;

                const distance = p1.distanceTo(p2);
                if (distance > 7) this.setGameState('fail', 'ğŸ’” í”Œë ˆì´ì–´ë“¤ì´ ë„ˆë¬´ ë©€ì–´ìš”! (ê±°ë¦¬: 7ë¯¸í„° ì´ë‚´ ìœ ì§€)');
                if (Math.abs(this.cake.mesh.rotation.x) > 0.8 || Math.abs(this.cake.mesh.rotation.z) > 0.8) {
                    this.setGameState('fail', 'ğŸ‚ ì¼€ì´í¬ê°€ ë–¨ì–´ì¡Œì–´ìš”! (ê¸°ìš¸ì„ ì¡°ì‹¬íˆ í•´ì£¼ì„¸ìš”)');
                }

                // ë„ë¡œ ì´íƒˆ íŒì •
                const roadLimit = this.roadWidth / 2 - 1.5; // ì¼€ì´í¬ ë°˜ì§€ë¦„ ê³ ë ¤
                if (Math.abs(this.cake.mesh.position.x) > roadLimit) {
                    this.setGameState('fail', 'ğŸ›£ï¸ ë„ë¡œ ë°–ìœ¼ë¡œ ì´íƒˆ! (ë„ë¡œ ì¤‘ì•™ ìœ ì§€í•˜ì„¸ìš”)');
                }
            }
            
            // 4ëª… ëª¨ë“œ ì¼€ì´í¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
            updateCoop4CakePosition() {
                const sortedPlayerIds = Object.keys(this.players).sort();
                const playerPositions = sortedPlayerIds.map(id => this.players[id].mesh.position);
                
                // 4ëª…ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
                const centerX = playerPositions.reduce((sum, pos) => sum + pos.x, 0) / 4;
                const centerZ = playerPositions.reduce((sum, pos) => sum + pos.z, 0) / 4;
                
                const targetPosition = new THREE.Vector3(centerX, 0, centerZ);
                this.cake.mesh.position.lerp(targetPosition, 0.08); // 4ì¸ ëª¨ë“œëŠ” ë” ë¶€ë“œëŸ½ê²Œ
                
                // 4ëª…ì˜ ë¶„ì‚°ë„ ê³„ì‚° (ë„ˆë¬´ í©ì–´ì¡ŒëŠ”ì§€ ì²´í¬)
                const maxDistance = Math.max(...playerPositions.map(pos => 
                    pos.distanceTo(targetPosition)
                ));
                
                // 4ì¸ í˜‘ë™ ì‹¤íŒ¨ ì¡°ê±´
                if (maxDistance > 8) {
                    this.setGameState('fail', 'ğŸ‘¥ íŒ€ì´ ë„ˆë¬´ í©ì–´ì¡Œì–´ìš”! (ìµœëŒ€ ê±°ë¦¬: 8ë¯¸í„° ì´ë‚´ ìœ ì§€)');
                    return;
                }
                
                // ì¼€ì´í¬ ê¸°ìš¸ê¸° ê³„ì‚° (4ëª…ì˜ í‰ê·  ê¸°ìš¸ê¸°)
                const avgTiltX = playerPositions.reduce((sum, pos, i, arr) => {
                    return sum + (i < arr.length - 1 ? pos.z - arr[i + 1].z : 0);
                }, 0) / 4;
                
                const avgTiltZ = playerPositions.reduce((sum, pos, i, arr) => {
                    return sum + (i < arr.length - 1 ? arr[i + 1].x - pos.x : 0);
                }, 0) / 4;
                
                this.cake.mesh.rotation.x = avgTiltX * 0.05; // 4ì¸ ëª¨ë“œëŠ” ë” ì•ˆì •ì 
                this.cake.mesh.rotation.z = avgTiltZ * 0.05;
                this.cake.mesh.rotation.y = 0;
                
                // ì¼€ì´í¬ ë–¨ì–´ëœ¨ë¦¼ íŒì • (4ì¸ ëª¨ë“œëŠ” ë” ê´€ëŒ€)
                if (Math.abs(this.cake.mesh.rotation.x) > 1.2 || Math.abs(this.cake.mesh.rotation.z) > 1.2) {
                    this.setGameState('fail', 'ğŸ‚ ëŒ€í˜• ì¼€ì´í¬ê°€ ë–¨ì–´ì¡Œì–´ìš”! (íŒ€ì›Œí¬ë¡œ ê· í˜• ìœ ì§€í•˜ì„¸ìš”)');
                }
                
                // ë„ë¡œ ì´íƒˆ íŒì • (ëŒ€í˜• ì¼€ì´í¬ ê³ ë ¤)
                const roadLimit = this.roadWidth / 2 - 2.5; // ëŒ€í˜• ì¼€ì´í¬ ë°˜ì§€ë¦„ ê³ ë ¤
                if (Math.abs(this.cake.mesh.position.x) > roadLimit) {
                    this.setGameState('fail', 'ğŸ›£ï¸ ëŒ€í˜• ì¼€ì´í¬ê°€ ë„ë¡œ ë°–ìœ¼ë¡œ ì´íƒˆ! (ë„“ì€ ë„ë¡œ, íŒ€ìœ¼ë¡œ ì¤‘ì•™ ìœ ì§€)');
                }
                
                console.log(`ğŸ‘¥ 4ì¸ í˜‘ë™ ì¼€ì´í¬ ì—…ë°ì´íŠ¸: ì¤‘ì‹¬(${centerX.toFixed(2)}, ${centerZ.toFixed(2)}), ìµœëŒ€ê±°ë¦¬: ${maxDistance.toFixed(2)}`);
            }
            
            // í”Œë ˆì´ì–´ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ëª¨ë“œë³„)
            resetPlayerPositions() {
                const playerIds = Object.keys(this.players);
                // ì„¼ì„œIDë¥¼ ì •ë ¬í•˜ì—¬ ì¼ê´€ëœ ìˆœì„œ ë³´ì¥ (1P, 2P, 3P, 4P ìˆœì„œ)
                const sortedPlayerIds = playerIds.sort();
                
                if (this.gameMode === 'coop4' && sortedPlayerIds.length === 4) {
                    // 4ì¸ í˜‘ë™ ëª¨ë“œ: ì‚¬ê°í˜• ë°°ì¹˜ (1P, 2P, 3P, 4P ìˆœì„œ)
                    const positions = [
                        { x: -3, z: -1 }, // 1P: ì¢Œìƒ
                        { x: 3, z: -1 },  // 2P: ìš°ìƒ  
                        { x: -3, z: 1 },  // 3P: ì¢Œí•˜
                        { x: 3, z: 1 }    // 4P: ìš°í•˜
                    ];
                    
                    sortedPlayerIds.forEach((playerId, index) => {
                        if (this.players[playerId] && positions[index]) {
                            this.players[playerId].mesh.position.set(
                                positions[index].x, 
                                0, 
                                positions[index].z
                            );
                            console.log(`ğŸ‘¥ ${index + 1}P í”Œë ˆì´ì–´ ë°°ì¹˜: ${playerId} â†’ (${positions[index].x}, 0, ${positions[index].z})`);
                        }
                    });
                } else {
                    // 2ì¸ ëª¨ë“œ: ì¢Œìš° ë°°ì¹˜ (1P, 2P ìˆœì„œ)
                    if (sortedPlayerIds.length >= 2) {
                        this.players[sortedPlayerIds[0]].mesh.position.set(-2, 0, 0); // 1P
                        this.players[sortedPlayerIds[1]].mesh.position.set(2, 0, 0);  // 2P
                        console.log(`ğŸ‘¥ 2ì¸ í”Œë ˆì´ì–´ ë°°ì¹˜: 1P(${sortedPlayerIds[0]}) â†’ (-2, 0, 0), 2P(${sortedPlayerIds[1]}) â†’ (2, 0, 0)`);
                    }
                }
            }

            checkCollisions() {
                if (!this.cake.mesh) return;
                const cakeBox = new THREE.Box3().setFromObject(this.cake.mesh);

                for (const obstacle of this.obstacles) {
                    const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                    if (cakeBox.intersectsBox(obstacleBox)) {
                        this.setGameState('fail', 'âš ï¸ ì¥ì• ë¬¼ê³¼ ì¶©ëŒ! (ì¥ì• ë¬¼ì„ í”¼í•´ì„œ ì´ë™í•˜ì„¸ìš”)');
                        return;
                    }
                }

                const destBox = new THREE.Box3().setFromObject(this.destination);
                if (cakeBox.intersectsBox(destBox)) {
                    this.handleDestinationReached();
                }
            }

            // ëª©ì ì§€ ë„ë‹¬ ì²˜ë¦¬ (ëª¨ë“œë³„)
            handleDestinationReached() {
                switch(this.gameMode) {
                    case 'normal':
                    case 'challenge':
                    case 'timeAttack':
                        // ë³„ì  ê³„ì‚°
                        const deliveryTime = Date.now() / 1000 - this.gameStartTime || 30;
                        const instability = this.cakePhysics ? this.cakePhysics.instability : 0;
                        this.stars = this.calculateStars(deliveryTime, instability);
                        console.log(`â­ ë³„ì  ê³„ì‚°: ${this.stars}/3 (ì‹œê°„: ${deliveryTime.toFixed(1)}ì´ˆ, ë¶ˆì•ˆì •ë„: ${instability.toFixed(2)})`);
                        
                        if (this.level < this.maxLevel) {
                            this.setGameState('level_clear', `ë ˆë²¨ ${this.level} í´ë¦¬ì–´! â­${this.stars}/3`);
                            this.level++;
                            this.safeSetTimeout(() => this.resetGame(true), 2000);
                        } else {
                            this.setGameState('success', `ğŸ‰ ìµœì¢… ë°°ë‹¬ ì„±ê³µ! â­${this.stars}/3\nì ìˆ˜: ${this.currentScore.toLocaleString()}`);
                        }
                        break;
                        
                    case 'infinite':
                        this.consecutiveDeliveries++;
                        this.infiniteLevel++;
                        this.currentScore += this.infiniteLevel * 100; // ë ˆë²¨ë‹¹ ë³´ë„ˆìŠ¤ ì¦ê°€
                        this.setGameState('level_clear', `ë¬´í•œ ë°°ë‹¬ ${this.consecutiveDeliveries}íšŒ ì„±ê³µ!`);
                        this.safeSetTimeout(() => this.resetGame(true), 2000);
                        console.log(`â™¾ï¸ ë¬´í•œ ëª¨ë“œ: ${this.consecutiveDeliveries}íšŒ ì—°ì† ë°°ë‹¬`);
                        break;
                        
                    case 'speedrun':
                        // ìµœì¢… ëª©ì ì§€ ë„ë‹¬
                        const finalTime = this.speedrunTime;
                        if (finalTime < this.speedrunBestTime) {
                            this.speedrunBestTime = finalTime;
                            localStorage.setItem('speedrunBest', finalTime.toString());
                            this.setGameState('success', `ğŸ‰ ì‹ ê¸°ë¡! ${finalTime.toFixed(1)}ì´ˆ`);
                        } else {
                            this.setGameState('success', `âš¡ ì™„ì£¼! ${finalTime.toFixed(1)}ì´ˆ (ìµœê³ : ${this.speedrunBestTime.toFixed(1)}ì´ˆ)`);
                        }
                        break;
                        
                    case 'relay':
                        // ë¦´ë ˆì´ ëª¨ë“œëŠ” updateRelayModeì—ì„œ ì²˜ë¦¬ë¨
                        if (this.currentSegment > this.relaySegments) {
                            this.setGameState('success', 'ğŸƒ ë¦´ë ˆì´ ë°°ë‹¬ ì™„ì£¼!');
                        }
                        break;
                        
                    case 'coop4':
                        // 4ì¸ í˜‘ë™ ì™„ë£Œ - ë³„ì  ê³„ì‚° ë° ì ìˆ˜ ì‹œìŠ¤í…œ
                        const coop4DeliveryTime = Date.now() / 1000 - this.gameStartTime || 30;
                        const coop4Instability = this.cakePhysics ? this.cakePhysics.instability : 0;
                        this.stars = this.calculateStars(coop4DeliveryTime, coop4Instability);
                        
                        // 4ì¸ í˜‘ë™ ë³´ë„ˆìŠ¤ ì ìˆ˜ ê³„ì‚°
                        const baseScore = this.calculateFinalScore(coop4DeliveryTime, this.currentCakeType, this.modeConfig.coop4.scoreMult);
                        const teamworkBonus = this.calculateTeamworkBonus(); // íŒ€ì›Œí¬ ë³´ë„ˆìŠ¤
                        const finalScore = baseScore + teamworkBonus;
                        
                        this.currentScore += finalScore;
                        this.updateHighScore();
                        
                        console.log(`ğŸ‘¥ 4ì¸ í˜‘ë™ ë°°ë‹¬ ì„±ê³µ! ì‹œê°„: ${coop4DeliveryTime.toFixed(1)}ì´ˆ, ë³„ì : ${this.stars}/3, ì ìˆ˜: ${finalScore}`);
                        this.setGameState('success', `ğŸ‘¥ 4ì¸ í˜‘ë™ ë°°ë‹¬ ì„±ê³µ!\nâ­${this.stars}/3 ì ìˆ˜: ${finalScore.toLocaleString()}`);
                        break;
                }
            }

            initAudio() {
                this.bgm = document.getElementById('bgm');
                this.sfxSuccess = document.getElementById('sfx-success');
                this.sfxFail = document.getElementById('sfx-fail');

                // BGM ìë™ ì¬ìƒì„ ìœ„í•œ ì²˜ë¦¬ (ì‚¬ìš©ì ì œìŠ¤ì²˜ í•„ìš”)
                document.addEventListener('click', () => {
                    if (this.bgm.paused) {
                        this.bgm.play().catch(e => console.log("BGM play failed:", e));
                    }
                }, { once: true });
            }

            playSound(soundElement) {
                soundElement.currentTime = 0;
                soundElement.play().catch(e => console.log("Sound play failed:", e));
            }

            setGameState(state, message) {
                if (this.gameState === 'fail' || this.gameState === 'success') return;
                console.log(`ğŸ® ê²Œì„ ìƒíƒœ ë³€ê²½: ${this.gameState} â†’ ${state} (${message})`);
                this.gameState = state;
                this.messageBox.textContent = message;
                this.messageBox.style.display = 'flex';
                if (state === 'fail' || state === 'success') {
                    this.resetButton.style.display = 'block';
                    this.bgm.pause();
                    if (state === 'success') {
                        this.playSound(this.sfxSuccess);
                        this.createParticles(this.cake.mesh.position, 0xffd700, 100); // ì„±ê³µ íŒŒí‹°í´ (ê¸ˆìƒ‰)
                        this.currentScore += (this.maxLevel * 100); // ìµœì¢… í´ë¦¬ì–´ ë³´ë„ˆìŠ¤
                    } else {
                        this.playSound(this.sfxFail);
                        this.createParticles(this.cake.mesh.position, 0xffa07a, 200); // ì‹¤íŒ¨ íŒŒí‹°í´ (ì£¼í™©ìƒ‰)
                        this.startCameraShake(0.5, 500); // ì‹¤íŒ¨ ì‹œ ì¹´ë©”ë¼ í”ë“¤ë¦¼
                    }
                    this.updateHighScore();
                    this.updateScoreDisplay();
                } else if (state === 'playing') {
                    this.bgm.play().catch(e => console.log("BGM play failed:", e));
                    // ê²Œì„ ì‹œì‘ ì‹œê°„ ê¸°ë¡
                    this.gameStartTime = Date.now() / 1000;
                    
                    // íƒ€ì„ ì–´íƒ ëª¨ë“œì—ì„œ ê²Œì„ ì‹œì‘ ì‹œ íƒ€ì´ë¨¸ í™œì„±í™”
                    if (this.gameMode === 'timeAttack') {
                        this.isTimerActive = true;
                        this.remainingTime = this.timeLimit;
                        console.log(`â° íƒ€ì„ ì–´íƒ ëª¨ë“œ íƒ€ì´ë¨¸ í™œì„±í™”: ${this.remainingTime}ì´ˆ`);
                    }
                    // ìŠ¤í”¼ë“œëŸ° ëª¨ë“œì—ì„œ ê²Œì„ ì‹œì‘ ì‹œ íƒ€ì´ë¨¸ ì´ˆê¸°í™”
                    if (this.gameMode === 'speedrun') {
                        this.speedrunTime = 0;
                    }
                } else if (state === 'level_clear') {
                    this.currentScore += (this.level * 100); // ë ˆë²¨ í´ë¦¬ì–´ ì ìˆ˜
                    this.updateScoreDisplay();
                }
            }

            updateScoreDisplay() {
                this.currentScoreDisplay.textContent = this.currentScore;
                this.highScoreDisplay.textContent = this.highScore;
            }

            updateHighScore() {
                if (this.currentScore > this.highScore) {
                    this.highScore = this.currentScore;
                    localStorage.setItem('cakeDeliveryHighScore', this.highScore);
                }
            }

            createParticles(position, color, count) {
                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                for (let i = 0; i < count; i++) {
                    const x = position.x + (Math.random() - 0.5) * 2;
                    const y = position.y + (Math.random() - 0.5) * 2;
                    const z = position.z + (Math.random() - 0.5) * 2;
                    vertices.push(x, y, z);
                }
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                const material = new THREE.PointsMaterial({ color: color, size: 0.2 });
                const particles = new THREE.Points(geometry, material);
                this.scene.add(particles);
                this.particles.push({ mesh: particles, velocity: new THREE.Vector3(), life: 100 });
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.mesh.position.add(p.velocity);
                    p.mesh.material.opacity -= 0.01;
                    p.life--;
                    if (p.life <= 0 || p.mesh.material.opacity <= 0) {
                        this.scene.remove(p.mesh);
                        this.particles.splice(i, 1);
                    }
                }
            }

            startCameraShake(intensity, duration) {
                this.cameraShake.intensity = intensity;
                this.cameraShake.decay = intensity / duration;
                this.cameraShake.startTime = Date.now();
            }

            updateCameraShake() {
                if (this.cameraShake.intensity > 0) {
                    const elapsed = Date.now() - this.cameraShake.startTime;
                    const currentIntensity = Math.max(0, this.cameraShake.intensity - this.cameraShake.decay * elapsed);

                    this.camera.position.x += (Math.random() - 0.5) * currentIntensity;
                    this.camera.position.y += (Math.random() - 0.5) * currentIntensity;

                    if (currentIntensity <= 0) {
                        this.cameraShake.intensity = 0;
                    }
                }
            }

            resetGame(isLevelUp = false) {
                // ëª¨ë“  í™œì„± íƒ€ì´ë¨¸ ì •ë¦¬
                this.clearAllTimers();
                
                if (!isLevelUp && Object.keys(this.players).length < 2) {
                    window.location.reload();
                    return;
                }

                if (!isLevelUp) {
                    this.level = 1;
                    this.currentScore = 0;
                    this.stars = 0; // ë³„ì  ì´ˆê¸°í™”
                }

                this.updateScoreDisplay();

                this.createLevel();

                // í”Œë ˆì´ì–´ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì • (ëª¨ë“œë³„ë¡œ ë‹¤ë¥´ê²Œ)
                this.resetPlayerPositions();

                // ê¸°ì¡´ ì¼€ì´í¬ ì œê±°í•˜ê³  ì„ íƒëœ íƒ€ì…ìœ¼ë¡œ ìƒˆë¡œ ìƒì„±
                if (this.cake.mesh) {
                    this.scene.remove(this.cake.mesh);
                    this.cake.mesh = null;
                }
                this.createCake(); // ì„ íƒëœ ì¼€ì´í¬ íƒ€ì…ìœ¼ë¡œ ìƒˆë¡œ ìƒì„±
                console.log(`ğŸ‚ ì¼€ì´í¬ ì¬ìƒì„±: ${this.currentCakeType}`);

                this.resetButton.style.display = 'none';
                this.gameState = 'ready';
                this.messageBox.textContent = isLevelUp ? `ë ˆë²¨ ${this.level} ì‹œì‘!` : '3ì´ˆ í›„ ë‹¤ì‹œ ì‹œì‘!';
                this.messageBox.style.display = 'flex';

                this.safeSetTimeout(() => {
                    this.setGameState('playing', '');
                    this.messageBox.style.display = 'none';
                }, 3000);
            }

            updateCamera() {
                if (!this.cake.mesh) return;
                const targetPosition = new THREE.Vector3();
                targetPosition.copy(this.cake.mesh.position);
                targetPosition.y += 15;
                targetPosition.z += 10;
                this.camera.position.lerp(targetPosition, 0.05);
                this.camera.lookAt(this.cake.mesh.position);
            }

            updateDynamicObstacles() {
                const roadLimit = this.roadWidth / 2 - 1.5; // ì¥ì• ë¬¼ ë°˜ì§€ë¦„ ê³ ë ¤
                this.obstacles.forEach(obstacle => {
                    if (obstacle.userData.moveDirection) { // ì›€ì§ì´ëŠ” ì¥ì• ë¬¼
                        obstacle.position.x += obstacle.userData.moveDirection * obstacle.userData.moveSpeed;
                        if (obstacle.position.x > roadLimit || obstacle.position.x < -roadLimit) {
                            obstacle.userData.moveDirection *= -1; // ë°©í–¥ ë°˜ì „
                        }
                    }
                    if (obstacle.userData.rotationSpeed) { // íšŒì „í•˜ëŠ” ì¥ì• ë¬¼
                        obstacle.rotation.y += obstacle.userData.rotationSpeed;
                    }
                });
            }

            animate() {
                requestAnimationFrame(this.animate);
                
                // ê²Œì„ ì‹œê°„ ì—…ë°ì´íŠ¸
                const deltaTime = this.clock.getDelta();
                
                if (this.gameState === 'playing') {
                    this.updateCakePosition();
                    this.updateCakePhysics(deltaTime);
                    this.updateGameModeLogic(deltaTime); // ëª¨ë“œë³„ ë¡œì§ ì¶”ê°€
                    this.checkCollisions();
                    this.updateDynamicObstacles();
                }
                this.updateCamera();
                this.updateParticles();
                this.updateCameraShake();
                this.updateEnvironmentEffects();
                this.starField.rotation.y += 0.0001; // ë³„ ë°°ê²½ ì›€ì§ì„
                this.renderer.render(this.scene, this.camera);
            }
            
            // ëª¨ë“œë³„ ê²Œì„ ë¡œì§ ì—…ë°ì´íŠ¸
            updateGameModeLogic(deltaTime) {
                switch(this.gameMode) {
                    case 'timeAttack':
                        this.updateTimeAttackMode(deltaTime);
                        break;
                    case 'speedrun':
                        this.updateSpeedrunMode(deltaTime);
                        break;
                    case 'relay':
                        this.updateRelayMode();
                        break;
                    case 'infinite':
                        this.updateInfiniteMode();
                        break;
                    case 'challenge':
                        this.updateChallengeMode();
                        break;
                    case 'coop4':
                        this.updateCoop4Mode();
                        break;
                }
            }

            // íƒ€ì„ ì–´íƒ ëª¨ë“œ ì—…ë°ì´íŠ¸
            updateTimeAttackMode(deltaTime) {
                if (this.isTimerActive && this.remainingTime > 0) {
                    this.remainingTime -= deltaTime;
                    if (this.remainingTime <= 0) {
                        this.remainingTime = 0;
                        this.setGameState('fail', 'â° ì‹œê°„ ì´ˆê³¼!');
                        return;
                    }
                    // UI ì—…ë°ì´íŠ¸
                    if (this.remainingTimeDisplay) {
                        this.remainingTimeDisplay.textContent = Math.ceil(this.remainingTime);
                        // ì‹œê°„ì´ ì–¼ë§ˆ ë‚¨ì§€ ì•Šì•˜ì„ ë•Œ ê²½ê³  ìƒ‰ìƒ
                        if (this.remainingTime <= 10) {
                            this.remainingTimeDisplay.style.color = '#ef4444'; // ë¹¨ê°„ìƒ‰
                        } else if (this.remainingTime <= 30) {
                            this.remainingTimeDisplay.style.color = '#f59e0b'; // ì£¼í™©ìƒ‰
                        }
                    }
                }
                
                // íƒ€ì„ì–´íƒ UI ê°•ì œ ì—…ë°ì´íŠ¸ (ë””ë²„ê¹…ìš©)
                if (this.gameMode === 'timeAttack' && this.remainingTimeDisplay) {
                    this.remainingTimeDisplay.textContent = Math.ceil(this.remainingTime);
                }
            }

            // ìŠ¤í”¼ë“œëŸ° ëª¨ë“œ ì—…ë°ì´íŠ¸
            updateSpeedrunMode(deltaTime) {
                this.speedrunTime += deltaTime;
                if (this.remainingTimeDisplay) {
                    this.remainingTimeDisplay.textContent = this.speedrunTime.toFixed(1);
                }
                
                // ì²´í¬í¬ì¸íŠ¸ í†µê³¼ ì²´í¬
                if (this.cake.mesh) {
                    for (let i = 0; i < this.speedrunCheckpoints.length; i++) {
                        const checkpoint = this.speedrunCheckpoints[i];
                        if (!checkpoint.reached) {
                            const distance = this.cake.mesh.position.distanceTo(checkpoint.position);
                            if (distance < 3) {
                                checkpoint.reached = true;
                                const timeBonus = Math.max(0, checkpoint.targetTime - this.speedrunTime);
                                this.currentScore += Math.floor(timeBonus * 100);
                                this.showStatusMessage(`âš¡ ì²´í¬í¬ì¸íŠ¸ ${i+1} í†µê³¼! (+${Math.floor(timeBonus * 100)}ì )`, 2000);
                                console.log(`âš¡ ì²´í¬í¬ì¸íŠ¸ ${i+1} í†µê³¼: ${this.speedrunTime.toFixed(1)}ì´ˆ`);
                            }
                            break; // ìˆœì„œëŒ€ë¡œ í†µê³¼í•´ì•¼ í•¨
                        }
                    }
                }
            }

            // ë¦´ë ˆì´ ëª¨ë“œ ì—…ë°ì´íŠ¸
            updateRelayMode() {
                if (this.cake.mesh && this.segmentTargets.length > 0) {
                    const currentTarget = this.segmentTargets[this.currentSegment - 1];
                    if (currentTarget && !currentTarget.reached) {
                        const distance = this.cake.mesh.position.distanceTo(currentTarget.position);
                        if (distance < 3) {
                            currentTarget.reached = true;
                            this.currentSegment++;
                            
                            if (this.currentSegment <= this.relaySegments) {
                                this.showStatusMessage(`ğŸƒ êµ¬ê°„ ${this.currentSegment-1} ì™„ë£Œ! ë‹¤ìŒ êµ¬ê°„ìœ¼ë¡œ!`, 3000);
                                console.log(`ğŸƒ ë¦´ë ˆì´ êµ¬ê°„ ${this.currentSegment-1} ì™„ë£Œ`);
                                // ë‹¤ìŒ êµ¬ê°„ ëª©ì ì§€ë¡œ ë³€ê²½
                                this.updateDestination(this.segmentTargets[this.currentSegment - 1].position);
                            } else {
                                // ëª¨ë“  êµ¬ê°„ ì™„ë£Œ
                                this.setGameState('success', 'ğŸƒ ë¦´ë ˆì´ ë°°ë‹¬ ì™„ì£¼!');
                            }
                        }
                    }
                }
            }

            // ë¬´í•œ ëª¨ë“œ ì—…ë°ì´íŠ¸  
            updateInfiniteMode() {
                // ë¬´í•œ ëª¨ë“œëŠ” checkCollisionsì—ì„œ ëª©ì ì§€ ë„ë‹¬ ì‹œ ë‹¤ìŒ ë ˆë²¨ë¡œ ìë™ ì§„í–‰
                // ë³„ë„ ì—…ë°ì´íŠ¸ ë¡œì§ ë¶ˆí•„ìš” (ì´ë¯¸ êµ¬í˜„ë¨)
            }

            // ì±Œë¦°ì§€ ëª¨ë“œ ì—…ë°ì´íŠ¸
            updateChallengeMode() {
                // ì±Œë¦°ì§€ ëª¨ë“œëŠ” ë†’ì€ ë‚œì´ë„ ì„¤ì •ìœ¼ë¡œ ì¶©ë¶„
                // ì¶”ê°€ì ì¸ íŠ¹ìˆ˜ íš¨ê³¼ë‚˜ ì œì•½ ì¡°ê±´ ì¶”ê°€ ê°€ëŠ¥
            }

            // 4ì¸ í˜‘ë™ ëª¨ë“œ ì—…ë°ì´íŠ¸
            updateCoop4Mode() {
                // 4ëª… í”Œë ˆì´ì–´ ìƒíƒœ ì²´í¬ ë° ëŒ€í˜• ì¼€ì´í¬ ê´€ë¦¬
                if (Object.keys(this.players).length === 4) {
                    // 4ëª…ì´ ëª¨ë‘ ì—°ê²°ëœ ìƒíƒœì—ì„œë§Œ íŠ¹ë³„í•œ ë¡œì§ ì‹¤í–‰
                    this.updateBigCakePhysics();
                }
            }

            // ëª©ì ì§€ ì—…ë°ì´íŠ¸ (ë¦´ë ˆì´ ëª¨ë“œìš©)
            updateDestination(newPosition) {
                if (this.destination) {
                    this.destination.position.copy(newPosition);
                }
            }

            // ëŒ€í˜• ì¼€ì´í¬ ë¬¼ë¦¬ (4ì¸ í˜‘ë™ìš©)
            updateBigCakePhysics() {
                // 4ëª…ì˜ ìœ„ì¹˜ë¥¼ ê³ ë ¤í•œ ì¼€ì´í¬ ìœ„ì¹˜ ê³„ì‚°
                if (this.cake.mesh && Object.keys(this.players).length === 4) {
                    const sortedPlayerIds = Object.keys(this.players).sort();
                const playerPositions = sortedPlayerIds.map(id => this.players[id].mesh.position);
                    const centerX = playerPositions.reduce((sum, pos) => sum + pos.x, 0) / 4;
                    const centerZ = playerPositions.reduce((sum, pos) => sum + pos.z, 0) / 4;
                    
                    const targetPos = new THREE.Vector3(centerX, 1, centerZ);
                    this.cake.mesh.position.lerp(targetPos, 0.05); // ë” ëŠë¦° ë°˜ì‘
                }
            }

            updateCakePhysics(deltaTime) {
                if (!this.cake.mesh || !this.currentCakeType || !this.cakePhysics) return;
                
                // deltaTime ê²€ì¦ ë° ì œí•œ (í”„ë ˆì„ ì•ˆì •ì„±)
                if (!isFinite(deltaTime) || deltaTime > 0.1) {
                    console.warn(`âš ï¸ ë¹„ì •ìƒì ì¸ deltaTime: ${deltaTime}, ê±´ë„ˆëœ€`);
                    return;
                }
                
                const config = this.cakeConfig[this.currentCakeType];
                if (!config) {
                    console.warn(`âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” ì¼€ì´í¬ íƒ€ì…: ${this.currentCakeType}`);
                    return;
                }
                
                // ì¼€ì´í¬ ë¬¼ë¦¬ ìƒíƒœ ê²€ì¦
                if (!this.validateCakePhysics()) {
                    console.warn('âš ï¸ ì¼€ì´í¬ ë¬¼ë¦¬ ìƒíƒœ ë¹„ì •ìƒ, ì´ˆê¸°í™”');
                    this.initializeCakePhysics(config);
                    return;
                }
                
                // ì¼€ì´í¬ íƒ€ì…ë³„ íŠ¹ìˆ˜ íš¨ê³¼
                this.applyCakeSpecialEffects(deltaTime, config);
                
                // ê³ ê¸‰ ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ì ìš©
                this.applyAdvancedPhysics(deltaTime);
                
                // ì¼€ì´í¬ ì •ë³´ UI ì—…ë°ì´íŠ¸ (í”„ë ˆì„ ìµœì í™” - 10fpsë¡œ ì œí•œ)
                if (!this.lastUIUpdate || Date.now() - this.lastUIUpdate > 100) {
                    this.updateCakeInfo();
                    this.lastUIUpdate = Date.now();
                }
            }
            
            // ì¼€ì´í¬ ë¬¼ë¦¬ ìƒíƒœ ê²€ì¦
            validateCakePhysics() {
                if (!this.cakePhysics) return false;
                
                // í•„ìˆ˜ ì†ì„± ì¡´ì¬ í™•ì¸
                const requiredProps = ['instability', 'temperature', 'velocity', 'angularVelocity', 'elasticity', 'viscosity'];
                for (const prop of requiredProps) {
                    if (this.cakePhysics[prop] === undefined || this.cakePhysics[prop] === null) {
                        return false;
                    }
                }
                
                // ìˆ˜ì¹˜ ê°’ ê²€ì¦
                const numericProps = ['instability', 'temperature', 'elasticity', 'viscosity'];
                for (const prop of numericProps) {
                    if (!isFinite(this.cakePhysics[prop])) {
                        return false;
                    }
                }
                
                // Vector3 ê²€ì¦
                if (!this.cakePhysics.velocity.isVector3 || !this.cakePhysics.angularVelocity.isVector3) {
                    return false;
                }
                
                return true;
            }
            
            applyCakeSpecialEffects(deltaTime, config) {
                switch(this.currentCakeType) {
                    case 'ice':
                        this.handleIceCakePhysics(deltaTime, config);
                        break;
                    case 'bomb':
                        this.handleBombCakePhysics(deltaTime, config);
                        break;
                    case 'wedding':
                        this.handleWeddingCakePhysics(deltaTime, config);
                        break;
                    case 'chocolate':
                        this.handleChocolateCakePhysics(deltaTime, config);
                        break;
                }
                
                // ë¶ˆì•ˆì •ì„±ì— ë”°ë¥¸ ì¼€ì´í¬ ë–¨ë¦¼ íš¨ê³¼
                this.applyCakeShakeEffect();
            }
            
            handleIceCakePhysics(deltaTime, config) {
                if (this.cakePhysics.meltingTimer > 0) {
                    this.cakePhysics.meltingTimer -= deltaTime;
                    
                    // ì˜¨ë„ ìƒìŠ¹ íš¨ê³¼
                    this.cakePhysics.temperature += deltaTime * 2;
                    
                    // ì¼€ì´í¬ í¬ê¸° ê°ì†Œ
                    const meltFactor = Math.max(0, this.cakePhysics.meltingTimer / 60);
                    this.cakePhysics.volume = 0.5 + meltFactor * 0.5;
                    this.cake.mesh.scale.setScalar(this.cakePhysics.volume);
                    
                    // ì•ˆì •ì„± ê°ì†Œ
                    this.cakePhysics.instability = 1.0 - (config.stability * meltFactor);
                    
                    // ì•¡ì²´í™” ì¦ê°€
                    this.cakePhysics.viscosity = Math.min(0.8, 0.1 + (1 - meltFactor) * 0.7);
                    
                    if (this.cakePhysics.meltingTimer <= 0) {
                        this.setGameState('fail', 'ğŸ¨ ì•„ì´ìŠ¤í¬ë¦¼ ì¼€ì´í¬ê°€ ë‹¤ ë…¹ì•˜ìŠµë‹ˆë‹¤! (ë¹ ë¥´ê²Œ ë°°ë‹¬í•˜ì„¸ìš”)');
                        return;
                    }
                }
            }
            
            handleBombCakePhysics(deltaTime, config) {
                if (this.cakePhysics.bombTimer > 0) {
                    this.cakePhysics.bombTimer -= deltaTime;
                    
                    // íƒ€ì´ë¨¸ì— ë”°ë¥¸ ë¶ˆì•ˆì •ì„± ì¦ê°€
                    const timerRatio = this.cakePhysics.bombTimer / 30;
                    this.cakePhysics.instability = 1.0 - (config.stability * timerRatio);
                    
                    // ì§„ë™ íš¨ê³¼
                    const vibrationIntensity = (1 - timerRatio) * 0.5;
                    this.cakePhysics.velocity.x += (Math.random() - 0.5) * vibrationIntensity;
                    this.cakePhysics.velocity.z += (Math.random() - 0.5) * vibrationIntensity;
                    
                    // íƒ€ì´ë¨¸ ì‹œê°ì  íš¨ê³¼
                    this.updateBombVisualEffects(timerRatio);
                    
                    if (this.cakePhysics.bombTimer <= 0) {
                        this.setGameState('fail', 'ğŸ’£ í­íƒ„ ì¼€ì´í¬ê°€ í­ë°œí–ˆìŠµë‹ˆë‹¤! (30ì´ˆ ì•ˆì— ë°°ë‹¬í•˜ì„¸ìš”)');
                        return;
                    }
                }
            }
            
            handleWeddingCakePhysics(deltaTime, config) {
                // ì›¨ë”© ì¼€ì´í¬ - ë†’ì€ ì¸µìœ¼ë¡œ ì¸í•œ ì¶”ê°€ ë¶ˆì•ˆì •ì„±
                const heightInstability = Math.abs(this.cake.mesh.rotation.x) + Math.abs(this.cake.mesh.rotation.z);
                this.cakePhysics.instability = (1.0 - config.stability) + heightInstability * 0.5;
                
                // ë‹¤ì¸µ êµ¬ì¡°ë¡œ ì¸í•œ ê°ì†ë„ ì¦ê°€
                const heightEffect = config.layers * 0.05;
                this.cakePhysics.angularVelocity.x += (Math.random() - 0.5) * heightEffect * deltaTime;
                this.cakePhysics.angularVelocity.z += (Math.random() - 0.5) * heightEffect * deltaTime;
            }
            
            handleChocolateCakePhysics(deltaTime, config) {
                // ì´ˆì½œë¦¿ ì¼€ì´í¬ - ì˜¨ë„ì— ë”°ë¥¸ ê²½í™”/ì—°í™”
                if (this.cakePhysics.temperature > 25) {
                    // ë…¹ì•„ì„œ ë¶€ë“œëŸ¬ì›Œì§
                    this.cakePhysics.elasticity = Math.max(0.2, this.cakePhysics.elasticity - deltaTime * 0.1);
                    this.cakePhysics.viscosity = Math.min(0.4, this.cakePhysics.viscosity + deltaTime * 0.1);
                }
                
                // ë¬´ê²Œê° ìˆëŠ” ì›€ì§ì„
                if (this.cake.mesh.position.y > 0) {
                    this.cake.mesh.position.y -= deltaTime * config.weight * 0.5;
                }
            }
            
            updateBombVisualEffects(timerRatio) {
                this.cake.mesh.children.forEach(child => {
                    if (child.geometry instanceof THREE.RingGeometry) {
                        const color = timerRatio > 0.5 ? 0xff0000 : 0xff4400;
                        child.material.color.setHex(color);
                        child.scale.setScalar(1 + (1 - timerRatio) * 0.3);
                    }
                });
            }
            
            applyCakeShakeEffect() {
                if (this.cakePhysics.instability > 0.3) {
                    const shakeIntensity = (this.cakePhysics.instability - 0.3) * 0.05;
                    this.cake.mesh.position.x += (Math.random() - 0.5) * shakeIntensity;
                    this.cake.mesh.position.z += (Math.random() - 0.5) * shakeIntensity;
                }
            }
            
            applyAdvancedPhysics(deltaTime) {
                if (!this.cake.mesh || !this.cakePhysics) return;
                
                const config = this.cakeConfig[this.currentCakeType];
                
                // ì¤‘ë ¥ ì ìš©
                this.applyGravity(deltaTime, config);
                
                // ë°”ëŒ íš¨ê³¼ ì ìš©
                this.applyWindEffects(deltaTime);
                
                // ì•¡ì²´ ë¬¼ë¦¬ (ì ì„± ê°ì‡ )
                this.applyViscosityDamping(deltaTime);
                
                // íƒ„ì„± íš¨ê³¼ (ì¼€ì´í¬ ë³€í˜•)
                this.applyElasticDeformation();
                
                // ì˜¨ë„ íš¨ê³¼
                this.updateTemperatureEffects(deltaTime);
                
                // ì†ë„ ì œí•œ ë° ë¬¼ë¦¬ ì—…ë°ì´íŠ¸
                this.finalizePhysicsUpdate(deltaTime);
            }
            
            applyGravity(deltaTime, config) {
                const mass = config.weight * this.cakePhysics.density;
                const gravityAcceleration = this.environmentForces.gravity.clone().multiplyScalar(mass * deltaTime * 0.1);
                this.cakePhysics.velocity.add(gravityAcceleration);
            }
            
            applyWindEffects(deltaTime) {
                const levelConfig = this.levelConfig[this.level];
                if (levelConfig?.wind > 0) {
                    // ë°”ëŒ ë°©í–¥ì„ ë¶€ë“œëŸ½ê²Œ ë³€í™”
                    const windStrength = levelConfig.wind * 0.1;
                    this.environmentForces.wind.set(
                        (Math.random() - 0.5) * windStrength,
                        0,
                        (Math.random() - 0.5) * windStrength * 0.3
                    );
                    this.cakePhysics.velocity.add(this.environmentForces.wind.clone().multiplyScalar(deltaTime));
                }
            }
            
            applyViscosityDamping(deltaTime) {
                const viscosityDamping = Math.max(0.8, 1 - (this.cakePhysics.viscosity * deltaTime));
                this.cakePhysics.velocity.multiplyScalar(viscosityDamping);
                this.cakePhysics.angularVelocity.multiplyScalar(viscosityDamping);
            }
            
            applyElasticDeformation() {
                const elasticDeformation = this.cakePhysics.elasticity * this.cakePhysics.instability;
                if (elasticDeformation > 0.1) {
                    // ì¼€ì´í¬ ëª¨ì–‘ ë³€í˜• (ë¶€ë“œëŸ½ê²Œ)
                    const targetDeformation = 1 - elasticDeformation * 0.05;
                    const currentScale = this.cake.mesh.scale.y;
                    this.cake.mesh.scale.y = THREE.MathUtils.lerp(currentScale, targetDeformation, 0.1);
                    
                    const horizontalScale = 1 + elasticDeformation * 0.02;
                    this.cake.mesh.scale.x = THREE.MathUtils.lerp(this.cake.mesh.scale.x, horizontalScale, 0.1);
                    this.cake.mesh.scale.z = THREE.MathUtils.lerp(this.cake.mesh.scale.z, horizontalScale, 0.1);
                }
            }
            
            finalizePhysicsUpdate(deltaTime) {
                // ì†ë„ ì œí•œ
                const maxVelocity = 3.0;
                if (this.cakePhysics.velocity.length() > maxVelocity) {
                    this.cakePhysics.velocity.normalize().multiplyScalar(maxVelocity);
                }
                
                // ê°ì†ë„ ì œí•œ
                const maxAngularVelocity = 2.0;
                if (this.cakePhysics.angularVelocity.length() > maxAngularVelocity) {
                    this.cakePhysics.angularVelocity.normalize().multiplyScalar(maxAngularVelocity);
                }
                
                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ë¶€ë“œëŸ½ê²Œ)
                const velocityDelta = this.cakePhysics.velocity.clone().multiplyScalar(deltaTime);
                this.cake.mesh.position.add(velocityDelta);
                
                // íšŒì „ ì—…ë°ì´íŠ¸
                this.cake.mesh.rotation.x += this.cakePhysics.angularVelocity.x * deltaTime;
                this.cake.mesh.rotation.y += this.cakePhysics.angularVelocity.y * deltaTime;
                this.cake.mesh.rotation.z += this.cakePhysics.angularVelocity.z * deltaTime;
                
                // ë°”ë‹¥ ì¶©ëŒ ì²˜ë¦¬
                if (this.cake.mesh.position.y < 0) {
                    this.cake.mesh.position.y = 0;
                    this.cakePhysics.velocity.y *= -this.cakePhysics.elasticity; // íƒ„ì„± ë°˜ë°œ
                }
            }
            
            updateTemperatureEffects(deltaTime) {
                if (!this.cakePhysics) return;
                
                // í™˜ê²½ë³„ ì˜¨ë„ ì„¤ì •
                const ambientTemperature = this.getAmbientTemperature();
                const temperatureChangeRate = 0.3; // ì˜¨ë„ ë³€í™”ìœ¨ (ë” ë¶€ë“œëŸ½ê²Œ)
                
                // ì˜¨ë„ í‰í˜•í™”
                const temperatureDiff = ambientTemperature - this.cakePhysics.temperature;
                this.cakePhysics.temperature += temperatureDiff * temperatureChangeRate * deltaTime;
                
                // ì˜¨ë„ë³„ ë¬¼ë¦¬ íš¨ê³¼
                this.applyTemperaturePhysics(deltaTime);
            }
            
            getAmbientTemperature() {
                switch(this.currentEnvironment) {
                    case 'desert': return 35;
                    case 'winter': return -5;
                    case 'night': return 15;
                    case 'beach': return 28;
                    default: return 25;
                }
            }
            
            applyTemperaturePhysics(deltaTime) {
                const temp = this.cakePhysics.temperature;
                
                if (temp > 30) {
                    // ëœ¨ê±°ì›Œì§ˆìˆ˜ë¡ ë” ë¶€ë“œëŸ¬ì›€
                    this.cakePhysics.elasticity = Math.max(0.1, this.cakePhysics.elasticity - deltaTime * 0.05);
                    this.cakePhysics.viscosity = Math.min(0.5, this.cakePhysics.viscosity + deltaTime * 0.05);
                } else if (temp < 0) {
                    // ì°¨ê°€ì›Œì§ˆìˆ˜ë¡ ë” ë‹¨ë‹¨í•¨
                    this.cakePhysics.elasticity = Math.min(0.9, this.cakePhysics.elasticity + deltaTime * 0.05);
                    this.cakePhysics.viscosity = Math.max(0.05, this.cakePhysics.viscosity - deltaTime * 0.05);
                }
            }
            
            // í™˜ê²½ íš¨ê³¼ ìµœì í™”
            optimizeEnvironmentEffects() {
                // í™˜ê²½ íš¨ê³¼ ê°ì²´ ìºì‹±
                if (!this.environmentEffectsCache) {
                    this.environmentEffectsCache = new Map();
                }
                
                // í˜„ì¬ í™˜ê²½ì— ëŒ€í•œ íš¨ê³¼ê°€ ìºì‹œë˜ì§€ ì•Šì•˜ë‹¤ë©´ ìƒì„±
                if (!this.environmentEffectsCache.has(this.currentEnvironment)) {
                    this.cacheEnvironmentEffects(this.currentEnvironment);
                }
            }
            
            cacheEnvironmentEffects(environmentType) {
                const effects = {
                    temperature: this.getAmbientTemperature(),
                    windModifier: this.getWindModifier(environmentType),
                    lightingConfig: this.getLightingConfig(environmentType)
                };
                
                this.environmentEffectsCache.set(environmentType, effects);
            }
            
            getWindModifier(environmentType) {
                switch(environmentType) {
                    case 'desert': return 1.5;
                    case 'winter': return 0.7;
                    case 'beach': return 1.2;
                    default: return 1.0;
                }
            }
            
            getLightingConfig(environmentType) {
                const config = this.environmentConfig[environmentType];
                return {
                    ambient: config.ambientLight,
                    directional: config.directionalLight,
                    fogNear: config.fogNear,
                    fogFar: config.fogFar
                };
            }
            
            updateEnvironmentEffects() {
                // í”„ë ˆì„ ìµœì í™” - í™˜ê²½ íš¨ê³¼ëŠ” 30fpsë¡œ ì œí•œ
                if (!this.lastEnvironmentUpdate || Date.now() - this.lastEnvironmentUpdate > 33) {
                    this.updateEnvironmentAnimation();
                    this.lastEnvironmentUpdate = Date.now();
                }
            }
            
            updateEnvironmentAnimation() {
                // í™˜ê²½ íš¨ê³¼ ìºì‹±ëœ ê°ì²´ë“¤ë§Œ ì—…ë°ì´íŠ¸
                if (this.environmentEffectsObjects) {
                    this.environmentEffectsObjects.forEach(obj => {
                        if (obj.userData.isSnow) {
                            this.updateSnowEffect(obj);
                        } else if (obj.children.length > 0) {
                            this.updateTreeSwayEffect(obj);
                        }
                    });
                }
            }
            
            updateSnowEffect(snowObject) {
                const positions = snowObject.geometry.attributes.position.array;
                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] -= 0.1; // ëˆˆ ë‚™í•˜
                    if (positions[i] < 0) {
                        positions[i] = 50; // ëˆˆ ì¬ìƒì„±
                    }
                }
                snowObject.geometry.attributes.position.needsUpdate = true;
            }
            
            updateTreeSwayEffect(treeObject) {
                const time = Date.now() * 0.001;
                treeObject.rotation.z = Math.sin(time + treeObject.position.x) * 0.015;
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            makeTextSprite(message, parameters) {
                const fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
                const fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 18;
                const borderThickness = parameters.hasOwnProperty("borderThickness") ? parameters["borderThickness"] : 4;
                const borderColor = parameters.hasOwnProperty("borderColor") ? parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
                const backgroundColor = parameters.hasOwnProperty("backgroundColor") ? parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };

                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                context.font = "Bold " + fontsize + "px " + fontface;

                const metrics = context.measureText(message);
                const textWidth = metrics.width;

                context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
                context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";

                context.lineWidth = borderThickness;
                // roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);

                context.fillStyle = "rgba(255, 255, 255, 1.0)";
                context.fillText(message, borderThickness, fontsize + borderThickness);

                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(8, 4, 1.0);
                return sprite;
            }
        }

        // ë„ì›€ë§ ì‹œìŠ¤í…œ í•¨ìˆ˜ë“¤
        function showHelp() {
            document.getElementById('helpPanel').style.display = 'block';
        }
        
        function hideHelp() {
            document.getElementById('helpPanel').style.display = 'none';
        }

        window.onload = () => {
            new CakeDeliveryGame();
            
            // ë„ì›€ë§ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            document.getElementById('helpButton').addEventListener('click', showHelp);
            
            // ESC í‚¤ë¡œ ë„ì›€ë§ ë‹«ê¸°
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    hideHelp();
                }
            });
        };
    </script>
</body>
</html>
